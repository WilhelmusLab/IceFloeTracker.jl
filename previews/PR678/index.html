<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IceFloeTracker.jl · IceFloeTracker.jl</title><meta name="title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="og:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="twitter:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta name="description" content="Documentation for IceFloeTracker.jl."/><meta property="og:description" content="Documentation for IceFloeTracker.jl."/><meta property="twitter:description" content="Documentation for IceFloeTracker.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="IceFloeTracker.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>IceFloeTracker.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>IceFloeTracker.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Algorithm-components"><span>Algorithm components</span></a></li><li><a class="tocitem" href="#Developers"><span>Developers</span></a></li><li><a class="tocitem" href="#Citing"><span>Citing</span></a></li><li><a class="tocitem" href="#Papers-using-Ice-Floe-Tracker"><span>Papers using Ice Floe Tracker</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="segmentation/">Segmentation</a></li><li><a class="tocitem" href="tracking/">Tracking</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IceFloeTracker.jl"><a class="docs-heading-anchor" href="#IceFloeTracker.jl">IceFloeTracker.jl</a><a id="IceFloeTracker.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IceFloeTracker.jl" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>IceFloeTracker.jl is a collection of routines and tools for processing remote sensing imagery, identifying sea ice floes, and tracking the displacement and rotation of ice floes across multiple images. It can be used either standalone to create custom processing pathways or with the <a href="https://github.com/WilhelmusLab/ice-floe-tracker-pipeline">Ice Floe Tracker Pipeline</a>.</p><ul><li><a href="#IceFloeTracker.jl">IceFloeTracker.jl</a></li><li class="no-marker"><ul><li><a href="#Overview">Overview</a></li><li><a href="#Algorithm-components">Algorithm components</a></li><li><a href="#Developers">Developers</a></li><li><a href="#Citing">Citing</a></li><li><a href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="preprocessing/#Preprocessing">Preprocessing</a></li><li class="no-marker"><ul><li><a href="preprocessing/#Land-masks">Land masks</a></li><li><a href="preprocessing/#Cloud-masks">Cloud masks</a></li><li><a href="preprocessing/#Image-regularization">Image regularization</a></li></ul></li><li><a href="segmentation/#Segmentation">Segmentation</a></li><li class="no-marker"><ul><li><a href="segmentation/#Ice/Water-Discrimination">Ice/Water Discrimination</a></li><li><a href="segmentation/#Feature-Identification">Feature Identification</a></li></ul></li><li><a href="tracking/#Tracking">Tracking</a></li></ul><h2 id="Algorithm-components"><a class="docs-heading-anchor" href="#Algorithm-components">Algorithm components</a><a id="Algorithm-components-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-components" title="Permalink"></a></h2><p>The Ice Floe Tracker (IFT) package includes the core functions for the three main steps of the algorithm. These functions can be used independently and can be customized for specific use cases. </p><h3 id="Preprocessing"><a class="docs-heading-anchor" href="#Preprocessing">Preprocessing</a><a id="Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing" title="Permalink"></a></h3><p>IFT operates on optical satellite imagery. The main functions are designed with &quot;true color&quot; and &quot;false color&quot; imagery in mind, and have thus far primarily been tested on imagery from the Moderate Resolution Imaging Spectroradiometer (MODIS) from the NASA <em>Aqua</em> and <em>Terra</em> satellites. The preprocessing routines mask land and cloud features, and aim to adjust and sharpen the remainder of the images to amplify the contrast along the edges of sea ice floes. (TBD: Link to main preprocessing page)</p><h3 id="Segmentation"><a class="docs-heading-anchor" href="#Segmentation">Segmentation</a><a id="Segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Segmentation" title="Permalink"></a></h3><p>The IFT segmentation functions include functions for semantic segmentation (pixel-by-pixel assignment into predefined categories) and object-based segmentation (groupings of pixels into distinct objects). The semantic segmentation steps use <span>$k$</span>-means to group pixels into water and ice regions. A combination of watershed functions, morphological operations, and further applications of <span>$k$</span>-means are used to identify candidate ice floes. (TBD: Link to main segmentation page)</p><h3 id="Tracking"><a class="docs-heading-anchor" href="#Tracking">Tracking</a><a id="Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking" title="Permalink"></a></h3><p>Ice floe tracking is carried out by comparing the shapes produced in the segmentation step. Shapes with similar area are rotated until the difference in surface area is minimized, and then the edge shapes are compared using a Ѱ-s curve. If thresholds for correlation and area differences are met, then the floe with the best correlation and smallest area differences are considered matches and the objects are assigned the same label. In the end, trajectories for individual floes are recorded in a dataframe.</p><h2 id="Developers"><a class="docs-heading-anchor" href="#Developers">Developers</a><a id="Developers-1"></a><a class="docs-heading-anchor-permalink" href="#Developers" title="Permalink"></a></h2><p>IceFloeTracker.jl is a product of the <a href="https://www.wilhelmuslab.me">Wilhelmus Lab</a> at Brown University, led by Monica M. Wilhelmus. The original algorithm was developed by Rosalinda Lopez-Acosta during her PhD work at University of California Riverside, advised by Dr. Wilhelmus. The translation of the original Matlab code into the current modular, open source Julia package has been carried out in conjunction with the Center for Computing and Visualization at Brown University. Contributors include Daniel Watkins, Maria Isabel Restrepo, Carlos Paniagua, Tim Divoll, John Holland, and Bradford Roarr.</p><h2 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h2><p>If you use IceFloeTracker.jl in research, teaching, or elsewhere, please mention the IceFloeTracker package and cite our journal article outlining the algorithm:</p><p>Lopez-Acosta et al., (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. <em>Remote Sensing of Environment</em>, <strong>234(111406)</strong>, doi:<a href="https://doi.org/10.1016/j.rse.2019.111406">10.1016/j.rse.2019.111406</a>.</p><h2 id="Papers-using-Ice-Floe-Tracker"><a class="docs-heading-anchor" href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a><a id="Papers-using-Ice-Floe-Tracker-1"></a><a class="docs-heading-anchor-permalink" href="#Papers-using-Ice-Floe-Tracker" title="Permalink"></a></h2><ol><li>Manucharyan, Lopez-Acosta, and Wilhelmus (2022)*. Spinning ice floes reveal intensification of mesoscale eddies in the western Arctic Ocean. <em>Scientific Reports</em>, <strong>12(7070)</strong>, doi:<a href="https://doi.org/10.1038/s41598-022-10712-z">10.1038/s41598-022-10712-z</a></li><li>Watkins, Bliss, Hutchings, and Wilhelmus (2023)*. Evidence of Abrupt Transitions Between Sea Ice Dynamical Regimes in the East Greenland Marginal Ice Zone. <em>Geophysical Research Letters</em>, <strong>50(e2023GL103558)</strong>, pp. 1-10, doi:<a href="https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2023GL103558">10.1029/2023GL103558</a></li></ol><p>*Papers using data from the Matlab implementation of Ice Floe Tracker.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.add_passtimes!-Tuple{Any, Any}" href="#IceFloeTracker.add_passtimes!-Tuple{Any, Any}"><code>IceFloeTracker.add_passtimes!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_passtimes!(props, passtimes)</code></pre><p>Add a column <code>passtime</code> to each DataFrame in <code>props</code> containing the time of the image in which the floes were captured.</p><p><strong>Arguments</strong></p><ul><li><code>props</code>: array of DataFrames containing floe properties.</li><li><code>passtimes</code>: array of <code>DateTime</code> objects containing the time of the image in which the floes were captured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/tracker.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.addfloemasks!-Tuple{DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}" href="#IceFloeTracker.addfloemasks!-Tuple{DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.addfloemasks!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addfloemasks!(props::DataFrame, floeimg::FloeLabelsImage)</code></pre><p>Add a column to <code>props</code> called <code>floearray</code> containing the cropped floe masks from <code>floeimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/regionprops.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.addlatlon!-Tuple{DataFrame, AbstractString}" href="#IceFloeTracker.addlatlon!-Tuple{DataFrame, AbstractString}"><code>IceFloeTracker.addlatlon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addlatlon(pairedfloesdf::DataFrame, refimage::AbstractString)</code></pre><p>Add columns <code>latitude</code>, <code>longitude</code>, and pixel coordinates <code>x</code>, <code>y</code> to <code>pairedfloesdf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pairedfloesdf</code>: dataframe containing floe tracking data.</li><li><code>refimage</code>: path to reference image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/tracker.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.addψs!-Tuple{Vector{DataFrame}}" href="#IceFloeTracker.addψs!-Tuple{Vector{DataFrame}}"><code>IceFloeTracker.addψs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addψs!(props::Vector{DataFrame})</code></pre><p>Add the ψ-s curves to each member of <code>props</code>.</p><p>Note: each member of <code>props</code> must have a <code>mask</code> column with a binary image representing the floe.</p><p>To add floe masks see <a href="#IceFloeTracker.addfloemasks!-Tuple{DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>addfloemasks!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/tracker-funcs.jl#L515-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.branch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch(img::AbstractArray{Bool})</code></pre><p>Find branch points in skeletonized image <code>img</code> according to Definition 3 of [1].</p><p>[1] Arcelli, Carlo, and Gabriella Sanniti di Baja. &quot;Skeletons of planar patterns.&quot; Machine Intelligence and Pattern Recognition. Vol. 19. North-Holland, 1996. 99-143.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/branch.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.bridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bridge(bw)</code></pre><p>Set 0-valued pixels to 1 if they have two nonzero neighbors that are not connected. Note the following exceptions:</p><p>0 0 0           0 0 0 1 0 1  becomes  1 1 1 0 0 0           0 0 0</p><p>1 0 1           1 1 1 0 0 0  becomes  0 0 0 0 0 0           0 0 0</p><p>The same applies to all their corresponding rotations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bw = [0 0 0; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 0  0  0
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 0  0  0
 0  0  0
 1  1  1

julia&gt; bw = [1 0 0; 1 0 1; 0 0 1]
3×3 Matrix{Int64}:
 1  0  0
 1  0  1
 0  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  0
 1  1  1
 0  1  1

 julia&gt; bw = [1 0 1; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 1  0  1
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  1
 1  1  1
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/bridge.jl#L27-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.callable_store-Tuple{}" href="#IceFloeTracker.callable_store-Tuple{}"><code>IceFloeTracker.callable_store</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">callable_store()</code></pre><p>Create a store and a callback function to add key-value pairs to the store.</p><p>Returns a <code>store::Dict</code> and a <code>callback::Function</code> which stores any kwargs passed to it in the <code>store</code>.</p><p><strong>Examples</strong></p><p>Basic usage is to store values using the callback function</p><pre><code class="language-julia-repl hljs">julia&gt; store, callback = callable_store()
julia&gt; store
Dict{Any, Any}()

julia&gt; callback(;foo=&quot;bar&quot;)  # echoes the updated store
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;

julia&gt; store  # values are available from the store object
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;</code></pre><p>A real-world use case is to extract data from a segmentation algorithm run:</p><pre><code class="language-julia-repl hljs">julia&gt; intermediate_results, intermediate_results_callback = callable_store()
julia&gt; data = first(Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)());
julia&gt; segments = LopezAcosta2019Tiling()(
    data.modis_truecolor,
    data.modis_falsecolor,
    data.modis_landmask;
    intermediate_results_callback,
)
Segmented Image with:
  labels map: 400×400 Matrix{Int64}
  number of labels: 12

julia&gt; intermediate_data
Dict{Any, Any} with 16 entries:
  :binarized_tiling                       =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :icemask                                =&gt; Bool[1 1 … 1 1; 1 1 … 1 1; … ; 0 0 … 1 1; 0 0 … 1 1]
  :equalized_gray                         =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :morphed_residue                        =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :L0mask                                 =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :segmented                              =&gt; Segmented Image with:…
  :prelim_icemask2                        =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :equalized_gray_sharpened_reconstructed =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :gammagreen                             =&gt; [190.35 190.23 … 182.93 185.03; 191.68 190.6 … 185.04 192.08; … ; 163.87 173.33 … 108.02 108.18; 166.14 173.3 … 112.35 112.32]
  :segment_mask                           =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :ref_img_cloudmasked                    =&gt; RGB{N0f8}[RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.008,0.706,0.761) RGB{N0f8}(0.0,0.722,0.769); RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.039,0.702,0.784) RGB{N0f8}(0.075,0.784,0.859); … ; RGB{…
  :prelim_icemask                         =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :equalized_gray_reconstructed           =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :final                                  =&gt; Bool[0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 1 0; 0 0 … 0 0]
  :local_maxima_mask                      =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :labeled                                =&gt; [0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 9 0; 0 0 … 0 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/utils.jl#L268-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.convertcentroid!-Tuple{Any, Any, Any}" href="#IceFloeTracker.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.convertcentroid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convertcentroid!(propdf, latlondata, colstodrop)</code></pre><p>Convert the centroid coordinates from row and column to latitude and longitude dropping unwanted columns specified in <code>colstodrop</code> for the output data structure. Addionally, add columns <code>x</code> and <code>y</code> with the pixel coordinates of the centroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/tracker-funcs.jl#L634-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.converttounits!-Tuple{Any, Any, Any}" href="#IceFloeTracker.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.converttounits!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">converttounits!(propdf, latlondata, colstodrop)</code></pre><p>Convert the floe properties from pixels to kilometers and square kilometers where appropiate. Also drop the columns specified in <code>colstodrop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/tracker-funcs.jl#L660-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.create_cloudmask" href="#IceFloeTracker.create_cloudmask"><code>IceFloeTracker.create_cloudmask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_cloudmask(img; f=AbstractCloudMaskAlgorithm)</code></pre><p>Cloud masks in the IFT are BitMatrix objects such that for an image I and cloudmask C, cloudy pixels can be selected by I[C], and clear-sky pixels can be selected with I[.!C]. Construction of a cloud mask uses the syntax</p><pre><code class="language-julia hljs">f = CloudMaskAlgorithm(parameters)
C = create_cloudmask(img; CloudMaskAlgorithm)</code></pre><p>By default, <code>create_cloudmask</code> uses the algorithm found in [1]. This algorithm converts a 3-channel MODIS 7-2-1 false color image into a 1-channel binary matrix in which clouds = 1 and anything else = 0. The algorithm aims to identify patches of opaque cloud while allowing thin and transparent cloud to remain. This algorithm is instantiated using</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask()</code></pre><p>In this case, the default values are applied. It can also called using a set of customized parameters. These values must be real numbers between 0 and 1. To reproduce the default parameters, you may call</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=110/255, band_7_threshold=200/255, band_2_threshold=190/255, ratio_lower=0.0, ratio_upper=0.75).</code></pre><p>A stricter cloud mask was defined in [2], covering more cloudy pixels while minimally impacting the masking of cloud-covered ice pixels.</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=53/255, band_7_threshold=130/255, band_2_threshold=169/255, ratio_lower=0.0, ratio_upper=0.53).</code></pre><p>These parameters together define a piecewise linear partition of pixels based on their Band 7 and Band 2 callibrated reflectance. Pixels with intensity above <code>prelim_threshold</code> are considered as potential cloudy pixels. Then, pixels with Band 7 reflectance less than <code>band_7_threshold</code>, Band 2 reflectance greater than <code>band_2_threshold</code>, and Band 7 to Band 2 ratios between <code>ratio_lower</code> and <code>ratio_upper</code> are removed from the cloud mask (i.e., set to cloud-free).</p><p><strong>Arguments</strong></p><ul><li><code>false_color_image</code>: corrected reflectance false color image - bands [7,2,1]</li><li><code>prelim_threshold</code>: threshold value used to identify clouds in band 7, N0f8(RGB intensity/255)</li><li><code>band_7_threshold</code>: threshold value used to identify cloud-ice in band 7, N0f8(RGB intensity/255)</li><li><code>band_2_threshold</code>: threshold value used to identify cloud-ice in band 2, N0f8(RGB intensity/255)</li><li><code>ratio_lower</code>: threshold value used to set lower ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_upper</code>: threshold value used to set upper ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_offset</code>: offset value used to adjust the upper ratio of cloud-ice in bands 7 and 2</li></ul><ol><li>Lopez-Acosta, R., Schodlok, M. P., &amp; Wilhelmus, M. M. (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. Remote Sensing of Environment, 234(111406), 1–15. (https://doi.org/10.1016/j.rse.2019.111406)[https://doi.org/10.1016/j.rse.2019.111406]</li><li>Watkins, D.M., Kim, M., Paniagua, C., Divoll, T., Holland, J.G., Hatcher, S., Hutchings, J.K., and Wilhelmus, M.M. (in prep). Calibration and validation of the Ice Floe Tracker algorithm. </li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/cloudmask.jl#L91-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)" href="#IceFloeTracker.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.create_landmask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_landmask(landmask_image, struct_elem, fill_value_lower, fill_value_upper)</code></pre><p>Convert a 3-channel RGB land mask image to a 1-channel binary matrix, and use a structuring element to extend a buffer to mask complex coastal features. In the resulting mask, land = 0 and ocean = 1. Returns a named tuple with the dilated and non-dilated landmask.</p><p><strong>Arguments</strong></p><ul><li><code>landmask_image</code>: RGB land mask image from <code>fetchdata</code></li><li><code>struct_elem</code>: structuring element for dilation (optional)</li><li><code>fill_value_lower</code>: fill holes having at least these many pixels (optional)</li><li><code>fill_value_upper</code>: fill holes having at most these many pixels (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/landmask.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrame, Integer}" href="#IceFloeTracker.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrame, Integer}"><code>IceFloeTracker.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, props, i)</code></pre><p>Crops the floe delimited by the bounding box data in <code>props</code> at index <code>i</code> from the floe image <code>floesimg</code>.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, but no <code>label</code>, then returns the largest contiguous component.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and a <code>label</code>, then returns the component with the label. In this case, <code>floesimg</code> must be an Array{Int}.</p><p>If the dataframe has only a <code>label</code> and no bounding box data, then returns the component with the label, padded by one cell of zeroes on all sides. In this case, <code>floesimg</code> must be an Array{Int}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/regionprops.jl#L186-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer" href="#IceFloeTracker.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col)</code></pre><p>Crops the floe delimited by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, from the floe image <code>floesimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/regionprops.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}" href="#IceFloeTracker.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col, label)</code></pre><p>Crops the floe from <code>floesimg</code> with the label <code>label</code>, returning the region bounded by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and converting to a BitMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/regionprops.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}" href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between two observations in DataFrameRows <code>row1</code> and <code>row2</code>. <code>image_column</code> and <code>time_column</code> specify which columns to use from the DataFrameRows. <code>registration_function</code> is used to compare the two images and should return an angle. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/rotation.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrame}" href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrame}"><code>IceFloeTracker.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between a measurement in a DataFrameRow <code>measurement</code>, and all the other rows in DataFrame <code>df</code>.</p><ul><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Returns a vector of <code>NamedTuple</code>s with one entry for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows for each comparison <code>row1</code> and <code>row2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/rotation.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.get_rotation_measurements-Tuple{DataFrame}" href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrame}"><code>IceFloeTracker.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between observations in DataFrame <code>df</code>.</p><ul><li><code>id_column</code> is the column with the ID of the image over several observations, e.g. the floe ID.</li><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Each row is compared to each other row in <code>df</code> which are:</p><ul><li>for the same object ID,</li><li>strictly older,</li><li>not older than the previous day.</li></ul><p>Returns a DataFrame with one row for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and all the other values from <code>df</code> with the column name suffix <code>1</code> for the first observation and <code>2</code> for the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/rotation.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{DateTime, TimeZones.ZonedDateTime}" href="#IceFloeTracker.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between two images <code>image1</code> and <code>image2</code> at times <code>time1</code> and <code>time2</code>. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>. <code>registration_function</code> is used to compare the two images and should return an angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/rotation.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.imsharpen" href="#IceFloeTracker.imsharpen"><code>IceFloeTracker.imsharpen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imsharpen(truecolor_image, landmask_no_dilate, lambda, kappa, niters, nbins, rblocks, cblocks, clip, smoothing_param, intensity)</code></pre><p>Sharpen <code>truecolor_image</code>.</p><p><strong>Arguments</strong></p><ul><li><code>truecolor_image</code>: input image in truecolor</li><li><code>landmask_no_dilate</code>: landmask for region of interest</li><li><code>lambda</code>: speed of diffusion (0–0.25)</li><li><code>kappa</code>: conduction coefficient for diffusion (25–100)</li><li><code>niters</code>: number of iterations of diffusion</li><li><code>nbins</code>: number of bins during histogram equalization</li><li><code>rblocks</code>: number of row blocks to divide input image during equalization</li><li><code>cblocks</code>: number of column blocks to divide input image during equalization</li><li><code>clip</code>: Thresholds for clipping histogram bins (0–1); values closer to one minimize contrast enhancement, values closer to zero maximize contrast enhancement</li><li><code>smoothing_param</code>: pixel radius for gaussian blurring (1–10)</li><li><code>intensity</code>: amount of sharpening to perform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/normalization.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.latlon-Tuple{AbstractString}" href="#IceFloeTracker.latlon-Tuple{AbstractString}"><code>IceFloeTracker.latlon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">latlon(imgpath::AbstractString)</code></pre><p>Reads the GeoTiff located at &lt;imgpath&gt;, extracts the coordinate reference system, and produces a lookup table with for the column and row values in the same projection as the GeoTiff and a 2D array for latitude and longitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/latlon.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.loadimg-Tuple{}" href="#IceFloeTracker.loadimg-Tuple{}"><code>IceFloeTracker.loadimg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadimg(; dir::String, fname::String)</code></pre><p>Load an image from <code>dir</code> with filename <code>fname</code> into a matrix of <code>Float64</code> values. Returns the loaded image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/utils.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.long_tracker-Tuple{Vector{DataFrame}, Any, Any}" href="#IceFloeTracker.long_tracker-Tuple{Vector{DataFrame}, Any, Any}"><code>IceFloeTracker.long_tracker</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">long_tracker(props, condition_thresholds, mc_thresholds)</code></pre><p>Track ice floes over multiple observations.</p><p>Trajectories are built as follows:</p><ul><li>Assume the floes detected in observation 1 are trajectories of length 1.</li><li>For each subsequent observation:<ul><li>Determine the latest observation for each trajectory – these are the &quot;current trajectory heads&quot;.</li><li>Find matches between the the current trajectory heads and the new observed floes, extending those trajectories.</li><li>Any unmatched floe in an observation is added as a new trajectory starting point.</li></ul></li></ul><p><strong>Arguments</strong></p><ul><li><code>props::Vector{DataFrame}</code>: A vector of DataFrames, each containing ice floe properties for a single day. Each DataFrame must have the following columns:<ul><li>&quot;area&quot;</li><li>&quot;min_row&quot;</li><li>&quot;min_col&quot;</li><li>&quot;max_row&quot;</li><li>&quot;max_col&quot;</li><li>&quot;row_centroid&quot;</li><li>&quot;col_centroid&quot;</li><li>&quot;convex_area&quot;</li><li>&quot;major<em>axis</em>length&quot;</li><li>&quot;minor<em>axis</em>length&quot;</li><li>&quot;orientation&quot;</li><li>&quot;perimeter&quot;</li><li>&quot;mask&quot;: 2D array of booleans</li><li>&quot;passtime&quot;: A timestamp for the floe</li><li>&quot;psi&quot;: the psi-s curve for the floe</li><li>&quot;uuid&quot;: a universally unique identifier for each segmented floe</li></ul></li><li><code>condition_thresholds</code>: namedtuple of thresholds for deciding whether to match floe <code>i</code> from day <code>k</code> to floe j from day <code>k+1</code>. See <code>IceFloeTracker.condition_thresholds</code> for sample values.</li><li><code>mc_thresholds</code>: thresholds for area mismatch and psi-s shape correlation. See <code>IceFloeTracker.mc_thresholds</code> for sample values.</li></ul><p><strong>Returns</strong></p><p>A DataFrame with the above columns, plus extra columns:</p><ul><li><code>area_mismatch</code> and <code>corr</code>, which are the area mismatch and correlation between a floe and the one that preceeds it in the trajectory. </li><li><code>head_uuid</code>, the floe which was best matched by this floe.</li><li>Trajectories are identified by: <ul><li>a unique identifier <code>ID</code> and the </li><li>UUID of the trajectory, <code>trajectory_uuid</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/long_tracker.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, F}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}" href="#IceFloeTracker.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, F}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}"><code>IceFloeTracker.matchcorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matchcorr(
f1::T,
f2::T,
Δt::F,
mxrot::S=10,
psi::F=0.95,
sz::S=16,
comp::F=0.25,
mm::F=0.22
)
where {T&lt;:AbstractArray{Bool,2},S&lt;:Int64,F&lt;:Float64}</code></pre><p>Compute the mismatch <code>mm</code> and psi-s-correlation <code>c</code> for floes with masks <code>f1</code> and <code>f2</code>.</p><p>The criteria for floes to be considered equivalent is as follows:     - <code>c</code> greater than <code>mm</code>      - <code>_mm</code> is less than <code>mm</code></p><p>A pair of <code>NaN</code> is returned for cases for which one of their mask dimension is too small or their sizes are not comparable.</p><p><strong>Arguments</strong></p><ul><li><code>f1</code>: mask of floe 1</li><li><code>f2</code>: mask of floe 2</li><li><code>Δt</code>: time difference between floes</li><li><code>mxrot</code>: maximum rotation (in degrees) allowed between floesn (default: 10)</li><li><code>psi</code>: psi-s-correlation threshold (default: 0.95)</li><li><code>sz</code>: size threshold (default: 16)</li><li><code>comp</code>: size comparability threshold (default: 0.25)</li><li><code>mm</code>: mismatch threshold (default: 0.22)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/tracker/matchcorr.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.padnhood-Tuple{Any, Any, Any}" href="#IceFloeTracker.padnhood-Tuple{Any, Any, Any}"><code>IceFloeTracker.padnhood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">padnhood(img, I, nhood)</code></pre><p>Pad the matrix <code>img[nhood]</code> with zeros according to the position of <code>I</code> within the edges<code>img</code>.</p><p>Returns <code>img[nhood]</code> if <code>I</code> is not an edge index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/utils.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.regionprops_table" href="#IceFloeTracker.regionprops_table"><code>IceFloeTracker.regionprops_table</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regionprops_table(label_img, intensity_img; properties, connectivity, extra_properties)</code></pre><p>A wrapper of the <code>regionprops_table</code> function from the skimage python library.</p><p>See its full documentation at https://scikit-image.org/docs/stable/api/skimage.measure.html#regionprops-table.</p><p><strong>Arguments</strong></p><ul><li><code>label_img</code>: Image with the labeled objects of interest</li><li><code>intensity_img</code>: (Optional) Used for generating <code>extra_properties</code>, integer/float array from which (presumably) <code>label_img</code> was generated </li><li><code>properties</code>: List (<code>Vector</code> or <code>Tuple</code>) of properties to be generated for each connected component in <code>label_img</code></li><li><code>extra_properties</code>: (Optional) not yet implemented. It will be set to <code>nothing</code></li></ul><p><strong>Notes</strong></p><ul><li>Zero indexing has been corrected for the <code>bbox</code> and <code>centroid</code> properties</li><li><code>bbox</code> data (<code>max_col</code> and <code>max_row</code>) are inclusive</li><li><code>centroid</code> data are rounded to the nearest integer</li></ul><p>See also <a href="@ref"><code>regionprops</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using IceFloeTracker, Random

julia&gt; Random.seed!(123);

julia&gt; bw_img = rand([0, 1], 5, 10)
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  1
 1  0  1  1  1  0  0  0  1  1
 1  1  0  1  1  0  1  0  0  1
 0  1  0  1  0  0  0  0  1  0
 1  0  0  0  0  1  0  1  0  1

julia&gt; label_img = IceFloeTracker.label_components(bw_img, trues(3,3))
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  4
 1  0  1  1  1  0  0  0  4  4
 1  1  0  1  1  0  3  0  0  4
 0  1  0  1  0  0  0  0  4  0
 1  0  0  0  0  2  0  4  0  4

julia&gt; properties = [&quot;area&quot;, &quot;perimeter&quot;]
2-element Vector{String}:
 &quot;area&quot;
 &quot;perimeter&quot;

 julia&gt; IceFloeTracker.regionprops_table(label_img, bw_img, properties = properties)
 4×2 DataFrame
  Row │ area   perimeter 
      │ Int32  Float64   
 ─────┼──────────────────
    1 │    13   11.6213
    2 │     1    0.0
    3 │     1    0.0
    4 │     7    4.62132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/regionprops.jl#L2-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}" href="#IceFloeTracker.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.segmentation_comparison</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function segmentation<em>comparison(     validated::SegmentedImage, measured::SegmentedImage )::@NamedTuple{recall::Real, precision::Real, F</em>score::Real}</p><p>Compares two SegmentedImages and returns values describing how similar the segmentations are.</p><p>This treats the segment labeled <code>0</code> as background.</p><p>Measures:</p><ul><li>precision: rate at which pixels in <code>validated</code> segments belong to <code>measured</code> segments</li><li>recall: rate at which pixels in <code>measured</code> segments belong to <code>validated</code> segments</li><li>F_score: harmonic mean of precision and recall</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/segmented-image-utilities.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.@persist" href="#IceFloeTracker.@persist"><code>IceFloeTracker.@persist</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@persist img fname
@persist(img,fname)
@persist img
@persist(img)
@persist img fname ts
@persist(img, fname, ts)</code></pre><p>Given a reference to an image object <code>img</code>, the macro persists (saves to a file) <code>img</code> to the current working directory using <code>fname</code> as filename. Returns <code>img</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: Symbol expression representing an image object loaded in memory.</li><li><code>fname</code>: Optional filename for the persisted image.</li><li><code>ts</code>: Optional boolean to attach timestamp to <code>fname</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/persist.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.ValidationDataLoader" href="#IceFloeTracker.ValidationDataLoader"><code>IceFloeTracker.ValidationDataLoader</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Loader for validated ice floe data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/validation_data.jl#L31-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Watkins2025GitHub" href="#IceFloeTracker.Watkins2025GitHub"><code>IceFloeTracker.Watkins2025GitHub</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Loader for validated ice floe data structured like https://github.com/danielmwatkins/ice<em>floe</em>validation_dataset.</p><pre><code class="nohighlight hljs">Struct fields:
- `url`: URL of the GitHub repository with the dataset
- `ref`: `git` ref of the commit from which to load the data
- `dataset_metadata_path`: path within the repository to a CSV file describing the data
- `cache_dir`: local path where the data will be stored.


Cacheing: 
Data are downloaded to the `ref` subdirectory of `cache_dir`, e.g. /tmp/Watkins2025/main`. 
If a file of the correct name already exists in that path, if loaded again the cached data will be returned.
If the data change in the source for that ref, the loader won&#39;t load the new data.
In that case, it&#39;s necessary to delete the cached file.
A better choice is to use a specific revision `ref`: either a tag, or a commit ID.

Function arguments:
- `case_filter`: function run on each metadata entry; 
  if it returns true, then the data from that case is returned 

Function returns a named tuple with these fields:
- `metadata`: DataFrame of the cases which passed the `case_filter`
- `data`: Generator which returns a `ValidationDataCase` for each case which passed the `case_filter`
    
Example:
```
julia&gt; data_loader = Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)
julia&gt; dataset = data_loader(;case_filter=c -&gt; (
                        c.visible_floes == &quot;yes&quot; &amp;&amp;
                        c.cloud_category_manual == &quot;none&quot; &amp;&amp;
                        c.artifacts == &quot;no&quot;
                    ));
julia&gt; dataset.metadata
8×28 DataFrame
 Row │ case_number  region        start_date  center_lon  center_lat  center_x  center_y  month  sea_ice_fr ⋯
     │ Int64        String31      Date        Float64     Float64     Int64     Int64     Int64  Float64    ⋯
─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │          11  baffin_bay    2011-07-02    -70.7347     72.3303   -837500  -1737500      7             ⋯
   2 │          14  baffin_bay    2022-07-06    -69.0755     72.3157   -787500  -1762500      7
   3 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
   4 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
   5 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5             ⋯
   6 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5
   7 │         128  hudson_bay    2019-04-15    -91.9847     57.853   -2612500  -2437500      4
   8 │         166  laptev_sea    2016-09-04    136.931      79.7507    -37500   1112500      9
                                                                                        20 columns omitted

julia&gt; first(dataset.data)
ValidationDataCase(&quot;011-baffin_bay-100km-20110702-aqua-250m&quot;, Dict{Symbol, Any}(:sea_ice_fraction =&gt; 0.8, :vi...

julia&gt; first(dataset.data).validated_labeled_floes
Segmented Image with:
labels map: 400×400 Matrix{Int64}
number of labels: 105
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/99d2fdf62a9992762fefb9d2bc2a118ccd4ab262/src/validation_data.jl#L36-L92">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#IceFloeTracker.ValidationDataLoader"><code>IceFloeTracker.ValidationDataLoader</code></a></li><li><a href="#IceFloeTracker.Watkins2025GitHub"><code>IceFloeTracker.Watkins2025GitHub</code></a></li><li><a href="#IceFloeTracker.add_passtimes!-Tuple{Any, Any}"><code>IceFloeTracker.add_passtimes!</code></a></li><li><a href="#IceFloeTracker.addfloemasks!-Tuple{DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.addfloemasks!</code></a></li><li><a href="#IceFloeTracker.addlatlon!-Tuple{DataFrame, AbstractString}"><code>IceFloeTracker.addlatlon!</code></a></li><li><a href="#IceFloeTracker.addψs!-Tuple{Vector{DataFrame}}"><code>IceFloeTracker.addψs!</code></a></li><li><a href="#IceFloeTracker.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.branch</code></a></li><li><a href="#IceFloeTracker.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.bridge</code></a></li><li><a href="#IceFloeTracker.callable_store-Tuple{}"><code>IceFloeTracker.callable_store</code></a></li><li><a href="#IceFloeTracker.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.convertcentroid!</code></a></li><li><a href="#IceFloeTracker.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.converttounits!</code></a></li><li><a href="#IceFloeTracker.create_cloudmask"><code>IceFloeTracker.create_cloudmask</code></a></li><li><a href="#IceFloeTracker.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.create_landmask</code></a></li><li><a href="#IceFloeTracker.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.cropfloe</code></a></li><li><a href="#IceFloeTracker.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.cropfloe</code></a></li><li><a href="#IceFloeTracker.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrame, Integer}"><code>IceFloeTracker.cropfloe</code></a></li><li><a href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrame}"><code>IceFloeTracker.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.get_rotation_measurements-Tuple{DataFrame}"><code>IceFloeTracker.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.imsharpen"><code>IceFloeTracker.imsharpen</code></a></li><li><a href="#IceFloeTracker.latlon-Tuple{AbstractString}"><code>IceFloeTracker.latlon</code></a></li><li><a href="#IceFloeTracker.loadimg-Tuple{}"><code>IceFloeTracker.loadimg</code></a></li><li><a href="#IceFloeTracker.long_tracker-Tuple{Vector{DataFrame}, Any, Any}"><code>IceFloeTracker.long_tracker</code></a></li><li><a href="#IceFloeTracker.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, F}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}"><code>IceFloeTracker.matchcorr</code></a></li><li><a href="#IceFloeTracker.padnhood-Tuple{Any, Any, Any}"><code>IceFloeTracker.padnhood</code></a></li><li><a href="#IceFloeTracker.regionprops_table"><code>IceFloeTracker.regionprops_table</code></a></li><li><a href="#IceFloeTracker.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.segmentation_comparison</code></a></li><li><a href="#IceFloeTracker.@persist"><code>IceFloeTracker.@persist</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="preprocessing/">Preprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 13 August 2025 12:41">Wednesday 13 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
