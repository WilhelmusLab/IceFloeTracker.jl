var documenterSearchIndex = {"docs":
[{"location":"tracking/#Tracking","page":"Tracking","title":"Tracking","text":"","category":"section"},{"location":"tracking/","page":"Tracking","title":"Tracking","text":"Ice floe tracking links objects in images pairwise.","category":"page"},{"location":"segmentation/#Segmentation","page":"Segmentation","title":"Segmentation","text":"","category":"section"},{"location":"segmentation/","page":"Segmentation","title":"Segmentation","text":"The segmentation functions are intended for use on the preprocessed imagery.","category":"page"},{"location":"segmentation/#Ice/Water-Discrimination","page":"Segmentation","title":"Ice/Water Discrimination","text":"","category":"section"},{"location":"segmentation/#Feature-Identification","page":"Segmentation","title":"Feature Identification","text":"","category":"section"},{"location":"preprocessing/#Preprocessing","page":"Preprocessing","title":"Preprocessing","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"IFT operates on optical satellite imagery. The main functions are designed with \"true color\" and \"false color\" imagery in mind, and have thus far primarily been tested on imagery from the Moderate Resolution Imaging Spectroradiometer (MODIS) from the NASA Aqua and Terra satellites. The preprocessing routines mask land and cloud features, and aim to adjust and sharpen the remainder of the images to amplify the contrast along the edges of sea ice floes. The functions use three different images: a land mask, a true color image, and a false color image. Examples are based on the NASA MODIS dataset.","category":"page"},{"location":"preprocessing/#Land-masks","page":"Preprocessing","title":"Land masks","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"Landmask generation and dilation is handled by the function create_landmask. Landmask images from file are loaded as RGB matrices. This example uses an image from NASA EarthData landmask for Beaufort Sea.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"using IceFloeTracker\n\nrgb_landmask = IceFloeTracker.load(<landmask_path>);\nlandmask_imgs = IceFloeTracker.create_landmask(rgb_landmask);","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"The landmask_imgs object includes a binary version of the original landmask and a dilated version, which helps to cover the complicated near-coastal regions.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"<img src=\"../assets/landmask_example.png\" width=\"600\" alt=\"Landmask Example\"/>","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"At the top, we have the original landmask TIFF, which has black and gray values. The middle image is the binary image, with land set to 0. At the bottom, we can see the dilated image using the default value of the structuring element. The default has radius 50, which results in a coastal mask of 12.5 km based on the 250 m pixel size of default MODIS imagery.","category":"page"},{"location":"preprocessing/#Cloud-masks","page":"Preprocessing","title":"Cloud masks","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"Setting thresholds for cloud mask","category":"page"},{"location":"preprocessing/#Image-regularization","page":"Preprocessing","title":"Image regularization","text":"","category":"section"},{"location":"#IceFloeTracker.jl","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"","category":"section"},{"location":"#Overview","page":"IceFloeTracker.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"IceFloeTracker.jl is a collection of routines and tools for processing remote sensing imagery, identifying sea ice floes, and tracking the displacement and rotation of ice floes across multiple images. It can be used either standalone to create custom processing pathways or with the Ice Floe Tracker Pipeline.","category":"page"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"","category":"page"},{"location":"#Algorithm-components","page":"IceFloeTracker.jl","title":"Algorithm components","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"The Ice Floe Tracker (IFT) package includes the core functions for the three main steps of the algorithm. These functions can be used independently and can be customized for specific use cases. ","category":"page"},{"location":"#Preprocessing","page":"IceFloeTracker.jl","title":"Preprocessing","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"IFT operates on optical satellite imagery. The main functions are designed with \"true color\" and \"false color\" imagery in mind, and have thus far primarily been tested on imagery from the Moderate Resolution Imaging Spectroradiometer (MODIS) from the NASA Aqua and Terra satellites. The preprocessing routines mask land and cloud features, and aim to adjust and sharpen the remainder of the images to amplify the contrast along the edges of sea ice floes. (TBD: Link to main preprocessing page)","category":"page"},{"location":"#Segmentation","page":"IceFloeTracker.jl","title":"Segmentation","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"The IFT segmentation functions include functions for semantic segmentation (pixel-by-pixel assignment into predefined categories) and object-based segmentation (groupings of pixels into distinct objects). The semantic segmentation steps use k-means to group pixels into water and ice regions. A combination of watershed functions, morphological operations, and further applications of k-means are used to identify candidate ice floes. (TBD: Link to main segmentation page)","category":"page"},{"location":"#Tracking","page":"IceFloeTracker.jl","title":"Tracking","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"Ice floe tracking is carried out by comparing the shapes produced in the segmentation step. Shapes with similar area are rotated until the difference in surface area is minimized, and then the edge shapes are compared using a Ѱ-s curve. If thresholds for correlation and area differences are met, then the floe with the best correlation and smallest area differences are considered matches and the objects are assigned the same label. In the end, trajectories for individual floes are recorded in a dataframe.","category":"page"},{"location":"#Developers","page":"IceFloeTracker.jl","title":"Developers","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"IceFloeTracker.jl is a product of the Wilhelmus Lab at Brown University, led by Monica M. Wilhelmus. The original algorithm was developed by Rosalinda Lopez-Acosta during her PhD work at University of California Riverside, advised by Dr. Wilhelmus. The translation of the original Matlab code into the current modular, open source Julia package has been carried out in conjunction with the Center for Computing and Visualization at Brown University. Contributors include Daniel Watkins, Maria Isabel Restrepo, Carlos Paniagua, Tim Divoll, John Holland, and Bradford Roarr.","category":"page"},{"location":"#Citing","page":"IceFloeTracker.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"If you use IceFloeTracker.jl in research, teaching, or elsewhere, please mention the IceFloeTracker package and cite our journal article outlining the algorithm:","category":"page"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"Lopez-Acosta et al., (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. Remote Sensing of Environment, 234(111406), doi:10.1016/j.rse.2019.111406.","category":"page"},{"location":"#Papers-using-Ice-Floe-Tracker","page":"IceFloeTracker.jl","title":"Papers using Ice Floe Tracker","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"Manucharyan, Lopez-Acosta, and Wilhelmus (2022)*. Spinning ice floes reveal intensification of mesoscale eddies in the western Arctic Ocean. Scientific Reports, 12(7070), doi:10.1038/s41598-022-10712-z\nWatkins, Bliss, Hutchings, and Wilhelmus (2023)*. Evidence of Abrupt Transitions Between Sea Ice Dynamical Regimes in the East Greenland Marginal Ice Zone. Geophysical Research Letters, 50(e2023GL103558), pp. 1-10, doi:10.1029/2023GL103558","category":"page"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"*Papers using data from the Matlab implementation of Ice Floe Tracker.","category":"page"},{"location":"#Functions","page":"IceFloeTracker.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"Modules = [IceFloeTracker]\nOrder   = [:function, :macro, :type]\nPrivate = false","category":"page"},{"location":"#IceFloeTracker.add_passtimes!-Tuple{Any, Any}","page":"IceFloeTracker.jl","title":"IceFloeTracker.add_passtimes!","text":"add_passtimes!(props, passtimes)\n\nAdd a column passtime to each DataFrame in props containing the time of the image in which the floes were captured.\n\nArguments\n\nprops: array of DataFrames containing floe properties.\npasstimes: array of DateTime objects containing the time of the image in which the floes were captured.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.addfloemasks!-Tuple{DataFrame, Union{BitMatrix, Matrix{<:Integer}}}","page":"IceFloeTracker.jl","title":"IceFloeTracker.addfloemasks!","text":"addfloemasks!(props::DataFrame, floeimg::FloeLabelsImage)\n\nAdd a column to props called floearray containing the cropped floe masks from floeimg.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.addlatlon!-Tuple{DataFrame, AbstractString}","page":"IceFloeTracker.jl","title":"IceFloeTracker.addlatlon!","text":"addlatlon(pairedfloesdf::DataFrame, refimage::AbstractString)\n\nAdd columns latitude, longitude, and pixel coordinates x, y to pairedfloesdf.\n\nArguments\n\npairedfloesdf: dataframe containing floe tracking data.\nrefimage: path to reference image.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.addψs!-Tuple{Vector{DataFrame}}","page":"IceFloeTracker.jl","title":"IceFloeTracker.addψs!","text":"addψs!(props::Vector{DataFrame})\n\nAdd the ψ-s curves to each member of props.\n\nNote: each member of props must have a mask column with a binary image representing the floe.\n\nTo add floe masks see addfloemasks!.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.branch-Tuple{T} where T<:(AbstractArray{Bool})","page":"IceFloeTracker.jl","title":"IceFloeTracker.branch","text":"branch(img::AbstractArray{Bool})\n\nFind branch points in skeletonized image img according to Definition 3 of [1].\n\n[1] Arcelli, Carlo, and Gabriella Sanniti di Baja. \"Skeletons of planar patterns.\" Machine Intelligence and Pattern Recognition. Vol. 19. North-Holland, 1996. 99-143.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.bridge-Tuple{T} where T<:(AbstractArray{Bool})","page":"IceFloeTracker.jl","title":"IceFloeTracker.bridge","text":"bridge(bw)\n\nSet 0-valued pixels to 1 if they have two nonzero neighbors that are not connected. Note the following exceptions:\n\n0 0 0           0 0 0 1 0 1  becomes  1 1 1 0 0 0           0 0 0\n\n1 0 1           1 1 1 0 0 0  becomes  0 0 0 0 0 0           0 0 0\n\nThe same applies to all their corresponding rotations.\n\nExamples\n\njulia> bw = [0 0 0; 0 0 0; 1 0 1]\n3×3 Matrix{Int64}:\n 0  0  0\n 0  0  0\n 1  0  1\n\njulia> bridge(bw)\n3×3 BitMatrix:\n 0  0  0\n 0  0  0\n 1  1  1\n\njulia> bw = [1 0 0; 1 0 1; 0 0 1]\n3×3 Matrix{Int64}:\n 1  0  0\n 1  0  1\n 0  0  1\n\njulia> bridge(bw)\n3×3 BitMatrix:\n 1  1  0\n 1  1  1\n 0  1  1\n\n julia> bw = [1 0 1; 0 0 0; 1 0 1]\n3×3 Matrix{Int64}:\n 1  0  1\n 0  0  0\n 1  0  1\n\njulia> bridge(bw)\n3×3 BitMatrix:\n 1  1  1\n 1  1  1\n 1  1  1\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.convertcentroid!-Tuple{Any, Any, Any}","page":"IceFloeTracker.jl","title":"IceFloeTracker.convertcentroid!","text":"convertcentroid!(propdf, latlondata, colstodrop)\n\nConvert the centroid coordinates from row and column to latitude and longitude dropping unwanted columns specified in colstodrop for the output data structure. Addionally, add columns x and y with the pixel coordinates of the centroid.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.converttounits!-Tuple{Any, Any, Any}","page":"IceFloeTracker.jl","title":"IceFloeTracker.converttounits!","text":"converttounits!(propdf, latlondata, colstodrop)\n\nConvert the floe properties from pixels to kilometers and square kilometers where appropiate. Also drop the columns specified in colstodrop.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.create_cloudmask-Tuple{Union{Matrix{RGB{Float64}}, Matrix{RGB{FixedPointNumbers.N0f8}}, Matrix{ColorTypes.RGBA{FixedPointNumbers.N0f8}}, Matrix{ColorTypes.XRGB{Float64}}}}","page":"IceFloeTracker.jl","title":"IceFloeTracker.create_cloudmask","text":"create_cloudmask(false_color_image; prelim_threshold, band_7_threshold, band_2_threshold, ratio_lower, ratio_upper)\n\nConvert a 3-channel false color reflectance image to a 1-channel binary matrix; clouds = 0, else = 1. Default thresholds are defined in the published Ice Floe Tracker article: Remote Sensing of the Environment 234 (2019) 111406.\n\nArguments\n\nfalse_color_image: corrected reflectance false color image - bands [7,2,1]\nprelim_threshold: threshold value used to identify clouds in band 7, N0f8(RGB intensity/255)\nband_7_threshold: threshold value used to identify cloud-ice in band 7, N0f8(RGB intensity/255)\nband_2_threshold: threshold value used to identify cloud-ice in band 2, N0f8(RGB intensity/255)\nratio_lower: threshold value used to set lower ratio of cloud-ice in bands 7 and 2\nratio_upper: threshold value used to set upper ratio of cloud-ice in bands 7 and 2\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T<:(AbstractMatrix)","page":"IceFloeTracker.jl","title":"IceFloeTracker.create_landmask","text":"create_landmask(landmask_image, struct_elem, fill_value_lower, fill_value_upper)\n\nConvert a 3-channel RGB land mask image to a 1-channel binary matrix, and use a structuring element to extend a buffer to mask complex coastal features. In the resulting mask, land = 0 and ocean = 1. Returns a named tuple with the dilated and non-dilated landmask.\n\nArguments\n\nlandmask_image: RGB land mask image from fetchdata\nstruct_elem: structuring element for dilation (optional)\nfill_value_lower: fill holes having at least these many pixels (optional)\nfill_value_upper: fill holes having at most these many pixels (optional)\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.cropfloe-Tuple{Union{BitMatrix, Matrix{<:Integer}}, DataFrame, Integer}","page":"IceFloeTracker.jl","title":"IceFloeTracker.cropfloe","text":"cropfloe(floesimg, props, i)\n\nCrops the floe delimited by the bounding box data in props at index i from the floe image floesimg.\n\nIf the dataframe has bounding box data min_row, min_col, max_row, max_col, but no label, then returns the largest contiguous component.\n\nIf the dataframe has bounding box data min_row, min_col, max_row, max_col, and a label, then returns the component with the label. In this case, floesimg must be an Array{Int}.\n\nIf the dataframe has only a label and no bounding box data, then returns the component with the label, padded by one cell of zeroes on all sides. In this case, floesimg must be an Array{Int}.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I<:Integer","page":"IceFloeTracker.jl","title":"IceFloeTracker.cropfloe","text":"cropfloe(floesimg, min_row, min_col, max_row, max_col)\n\nCrops the floe delimited by min_row, min_col, max_row, max_col, from the floe image floesimg.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I<:Integer, J<:Integer}","page":"IceFloeTracker.jl","title":"IceFloeTracker.cropfloe","text":"cropfloe(floesimg, min_row, min_col, max_row, max_col, label)\n\nCrops the floe from floesimg with the label label, returning the region bounded by min_row, min_col, max_row, max_col, and converting to a BitMatrix.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}","page":"IceFloeTracker.jl","title":"IceFloeTracker.get_rotation_measurements","text":"Calculate the angle and rotation rate between two observations in DataFrameRows row1 and row2. image_column and time_column specify which columns to use from the DataFrameRows. registration_function is used to compare the two images and should return an angle. Returns a NamedTuple with the angle theta_rad, time difference dt_sec and rotation rate omega_rad_per_sec, and the two input rows.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrame}","page":"IceFloeTracker.jl","title":"IceFloeTracker.get_rotation_measurements","text":"Calculate the angle and rotation rate between a measurement in a DataFrameRow measurement, and all the other rows in DataFrame df.\n\nimage_column is the column with the image to compare, \ntime_column is the column with the timepoint of each observation,\nregistration_function is used to compare the two images and should return an angle.\n\nReturns a vector of NamedTuples with one entry for each comparison, with the angle theta_rad, time difference dt_sec and rotation rate omega_rad_per_sec, and the two input rows for each comparison row1 and row2.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.get_rotation_measurements-Tuple{DataFrame}","page":"IceFloeTracker.jl","title":"IceFloeTracker.get_rotation_measurements","text":"Calculate the angle and rotation rate between observations in DataFrame df.\n\nid_column is the column with the ID of the image over several observations, e.g. the floe ID.\nimage_column is the column with the image to compare, \ntime_column is the column with the timepoint of each observation,\nregistration_function is used to compare the two images and should return an angle.\n\nEach row is compared to each other row in df which are:\n\nfor the same object ID,\nstrictly older,\nnot older than the previous day.\n\nReturns a DataFrame with one row for each comparison, with the angle theta_rad, time difference dt_sec and rotation rate omega_rad_per_sec, and all the other values from df with the column name suffix 1 for the first observation and 2 for the second.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T<:Union{DateTime, TimeZones.ZonedDateTime}","page":"IceFloeTracker.jl","title":"IceFloeTracker.get_rotation_measurements","text":"Calculate the angle and rotation rate between two images image1 and image2 at times time1 and time2. Returns a NamedTuple with the angle theta_rad, time difference dt_sec and rotation rate omega_rad_per_sec. registration_function is used to compare the two images and should return an angle.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.imsharpen","page":"IceFloeTracker.jl","title":"IceFloeTracker.imsharpen","text":"imsharpen(truecolor_image, landmask_no_dilate, lambda, kappa, niters, nbins, rblocks, cblocks, clip, smoothing_param, intensity)\n\nSharpen truecolor_image.\n\nArguments\n\ntruecolor_image: input image in truecolor\nlandmask_no_dilate: landmask for region of interest\nlambda: speed of diffusion (0–0.25)\nkappa: conduction coefficient for diffusion (25–100)\nniters: number of iterations of diffusion\nnbins: number of bins during histogram equalization\nrblocks: number of row blocks to divide input image during equalization\ncblocks: number of column blocks to divide input image during equalization\nclip: Thresholds for clipping histogram bins (0–1); values closer to one minimize contrast enhancement, values closer to zero maximize contrast enhancement\nsmoothing_param: pixel radius for gaussian blurring (1–10)\nintensity: amount of sharpening to perform\n\n\n\n\n\n","category":"function"},{"location":"#IceFloeTracker.latlon-Tuple{AbstractString}","page":"IceFloeTracker.jl","title":"IceFloeTracker.latlon","text":"latlon(imgpath::AbstractString)\n\nReads the GeoTiff located at <imgpath>, extracts the coordinate reference system, and produces a lookup table with for the column and row values in the same projection as the GeoTiff and a 2D array for latitude and longitude.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.loadimg-Tuple{}","page":"IceFloeTracker.jl","title":"IceFloeTracker.loadimg","text":"loadimg(; dir::String, fname::String)\n\nLoad an image from dir with filename fname into a matrix of Float64 values. Returns the loaded image.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.long_tracker-Tuple{Vector{DataFrame}, Any, Any}","page":"IceFloeTracker.jl","title":"IceFloeTracker.long_tracker","text":"long_tracker(props, condition_thresholds, mc_thresholds)\n\nTrack ice floes over multiple observations.\n\nTrajectories are built as follows:\n\nAssume the floes detected in observation 1 are trajectories of length 1.\nFor each subsequent observation:\nDetermine the latest observation for each trajectory – these are the \"current trajectory heads\".\nFind matches between the the current trajectory heads and the new observed floes, extending those trajectories.\nAny unmatched floe in an observation is added as a new trajectory starting point.\n\nArguments\n\nprops::Vector{DataFrame}: A vector of DataFrames, each containing ice floe properties for a single day. Each DataFrame must have the following columns:\n\"area\"\n\"min_row\"\n\"min_col\"\n\"max_row\"\n\"max_col\"\n\"row_centroid\"\n\"col_centroid\"\n\"convex_area\"\n\"majoraxislength\"\n\"minoraxislength\"\n\"orientation\"\n\"perimeter\"\n\"mask\": 2D array of booleans\n\"passtime\": A timestamp for the floe\n\"psi\": the psi-s curve for the floe\n\"uuid\": a universally unique identifier for each segmented floe\ncondition_thresholds: namedtuple of thresholds for deciding whether to match floe i from day k to floe j from day k+1. See IceFloeTracker.condition_thresholds for sample values.\nmc_thresholds: thresholds for area mismatch and psi-s shape correlation. See IceFloeTracker.mc_thresholds for sample values.\n\nReturns\n\nA DataFrame with the above columns, plus extra columns:\n\narea_mismatch and corr, which are the area mismatch and correlation between a floe and the one that preceeds it in the trajectory. \nhead_uuid, the floe which was best matched by this floe.\nTrajectories are identified by: \na unique identifier ID and the \nUUID of the trajectory, trajectory_uuid.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, F}} where {T<:AbstractMatrix{Bool}, S<:Int64, F<:Float64}","page":"IceFloeTracker.jl","title":"IceFloeTracker.matchcorr","text":"matchcorr(\nf1::T,\nf2::T,\nΔt::F,\nmxrot::S=10,\npsi::F=0.95,\nsz::S=16,\ncomp::F=0.25,\nmm::F=0.22\n)\nwhere {T<:AbstractArray{Bool,2},S<:Int64,F<:Float64}\n\nCompute the mismatch mm and psi-s-correlation c for floes with masks f1 and f2.\n\nThe criteria for floes to be considered equivalent is as follows:     - c greater than mm      - _mm is less than mm\n\nA pair of NaN is returned for cases for which one of their mask dimension is too small or their sizes are not comparable.\n\nArguments\n\nf1: mask of floe 1\nf2: mask of floe 2\nΔt: time difference between floes\nmxrot: maximum rotation (in degrees) allowed between floesn (default: 10)\npsi: psi-s-correlation threshold (default: 0.95)\nsz: size threshold (default: 16)\ncomp: size comparability threshold (default: 0.25)\nmm: mismatch threshold (default: 0.22)\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.padnhood-Tuple{Any, Any, Any}","page":"IceFloeTracker.jl","title":"IceFloeTracker.padnhood","text":"padnhood(img, I, nhood)\n\nPad the matrix img[nhood] with zeros according to the position of I within the edgesimg.\n\nReturns img[nhood] if I is not an edge index.\n\n\n\n\n\n","category":"method"},{"location":"#IceFloeTracker.regionprops_table","page":"IceFloeTracker.jl","title":"IceFloeTracker.regionprops_table","text":"regionprops_table(label_img, intensity_img; properties, connectivity, extra_properties)\n\nA wrapper of the regionprops_table function from the skimage python library.\n\nSee its full documentation at https://scikit-image.org/docs/stable/api/skimage.measure.html#regionprops-table.\n\nArguments\n\nlabel_img: Image with the labeled objects of interest\nintensity_img: (Optional) Used for generating extra_properties, integer/float array from which (presumably) label_img was generated \nproperties: List (Vector or Tuple) of properties to be generated for each connected component in label_img\nextra_properties: (Optional) not yet implemented. It will be set to nothing\n\nNotes\n\nZero indexing has been corrected for the bbox and centroid properties\nbbox data (max_col and max_row) are inclusive\ncentroid data are rounded to the nearest integer\n\nSee also regionprops\n\nExamples\n\njulia> using IceFloeTracker, Random\n\njulia> Random.seed!(123);\n\njulia> bw_img = rand([0, 1], 5, 10)\n5×10 Matrix{Int64}:\n 1  0  1  0  0  0  0  0  0  1\n 1  0  1  1  1  0  0  0  1  1\n 1  1  0  1  1  0  1  0  0  1\n 0  1  0  1  0  0  0  0  1  0\n 1  0  0  0  0  1  0  1  0  1\n\njulia> label_img = IceFloeTracker.label_components(bw_img, trues(3,3))\n5×10 Matrix{Int64}:\n 1  0  1  0  0  0  0  0  0  4\n 1  0  1  1  1  0  0  0  4  4\n 1  1  0  1  1  0  3  0  0  4\n 0  1  0  1  0  0  0  0  4  0\n 1  0  0  0  0  2  0  4  0  4\n\njulia> properties = [\"area\", \"perimeter\"]\n2-element Vector{String}:\n \"area\"\n \"perimeter\"\n\n julia> IceFloeTracker.regionprops_table(label_img, bw_img, properties = properties)\n 4×2 DataFrame\n  Row │ area   perimeter \n      │ Int32  Float64   \n ─────┼──────────────────\n    1 │    13   11.6213\n    2 │     1    0.0\n    3 │     1    0.0\n    4 │     7    4.62132\n\n\n\n\n\n","category":"function"},{"location":"#IceFloeTracker.@persist","page":"IceFloeTracker.jl","title":"IceFloeTracker.@persist","text":"@persist img fname\n@persist(img,fname)\n@persist img\n@persist(img)\n@persist img fname ts\n@persist(img, fname, ts)\n\nGiven a reference to an image object img, the macro persists (saves to a file) img to the current working directory using fname as filename. Returns img.\n\nArguments\n\nimg: Symbol expression representing an image object loaded in memory.\nfname: Optional filename for the persisted image.\nts: Optional boolean to attach timestamp to fname.\n\n\n\n\n\n","category":"macro"},{"location":"#Index","page":"IceFloeTracker.jl","title":"Index","text":"","category":"section"},{"location":"","page":"IceFloeTracker.jl","title":"IceFloeTracker.jl","text":"","category":"page"}]
}
