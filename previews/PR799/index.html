<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IceFloeTracker.jl · IceFloeTracker.jl</title><meta name="title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="og:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="twitter:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta name="description" content="Documentation for IceFloeTracker.jl."/><meta property="og:description" content="Documentation for IceFloeTracker.jl."/><meta property="twitter:description" content="Documentation for IceFloeTracker.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="IceFloeTracker.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>IceFloeTracker.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>IceFloeTracker.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Algorithm-components"><span>Algorithm components</span></a></li><li><a class="tocitem" href="#Developers"><span>Developers</span></a></li><li><a class="tocitem" href="#Citing"><span>Citing</span></a></li><li><a class="tocitem" href="#Papers-using-Ice-Floe-Tracker"><span>Papers using Ice Floe Tracker</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="segmentation/">Segmentation</a></li><li><a class="tocitem" href="tracking/">Tracking</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/lopez-acosta-2019-workflow/">Segmentation Algorithm Workflows</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/main/docs/prebuild/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IceFloeTracker.jl"><a class="docs-heading-anchor" href="#IceFloeTracker.jl">IceFloeTracker.jl</a><a id="IceFloeTracker.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IceFloeTracker.jl" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>IceFloeTracker.jl is a collection of routines and tools for processing remote sensing imagery, identifying sea ice floes, and tracking the displacement and rotation of ice floes across multiple images. It can be used either standalone to create custom processing pathways or with the <a href="https://github.com/WilhelmusLab/ice-floe-tracker-pipeline">Ice Floe Tracker Pipeline</a>.</p><ul><li><a href="#IceFloeTracker.jl">IceFloeTracker.jl</a></li><li class="no-marker"><ul><li><a href="#Overview">Overview</a></li><li><a href="#Algorithm-components">Algorithm components</a></li><li><a href="#Developers">Developers</a></li><li><a href="#Citing">Citing</a></li><li><a href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="preprocessing/#Preprocessing">Preprocessing</a></li><li class="no-marker"><ul><li><a href="preprocessing/#Land-masks">Land masks</a></li><li><a href="preprocessing/#Cloud-masks">Cloud masks</a></li><li><a href="preprocessing/#Image-regularization">Image regularization</a></li></ul></li><li><a href="segmentation/#Segmentation">Segmentation</a></li><li class="no-marker"><ul><li><a href="segmentation/#Ice/Water-Discrimination">Ice/Water Discrimination</a></li><li><a href="segmentation/#Feature-Identification">Feature Identification</a></li></ul></li><li><a href="tracking/#Tracking">Tracking</a></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Segmentation-Algorithm-Workflows">Segmentation Algorithm Workflows</a></li><li class="no-marker"><ul><li><a href="tutorials/lopez-acosta-2019-workflow/#Load-the-images">Load the images</a></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Run-the-segmentation-algorithm">Run the segmentation algorithm</a></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Run-the-segmentation-algorithm-with-tiling">Run the segmentation algorithm with tiling</a></li></ul></li></ul><h2 id="Algorithm-components"><a class="docs-heading-anchor" href="#Algorithm-components">Algorithm components</a><a id="Algorithm-components-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-components" title="Permalink"></a></h2><p>The Ice Floe Tracker (IFT) package includes the core functions for the three main steps of the algorithm. These functions can be used independently and can be customized for specific use cases. </p><h3 id="Preprocessing"><a class="docs-heading-anchor" href="#Preprocessing">Preprocessing</a><a id="Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing" title="Permalink"></a></h3><p>IFT operates on optical satellite imagery. The main functions are designed with &quot;true color&quot; and &quot;false color&quot; imagery in mind, and have thus far primarily been tested on imagery from the Moderate Resolution Imaging Spectroradiometer (MODIS) from the NASA <em>Aqua</em> and <em>Terra</em> satellites. The preprocessing routines mask land and cloud features, and aim to adjust and sharpen the remainder of the images to amplify the contrast along the edges of sea ice floes. (TBD: Link to main preprocessing page)</p><h3 id="Segmentation"><a class="docs-heading-anchor" href="#Segmentation">Segmentation</a><a id="Segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Segmentation" title="Permalink"></a></h3><p>The IFT segmentation functions include functions for semantic segmentation (pixel-by-pixel assignment into predefined categories) and object-based segmentation (groupings of pixels into distinct objects). The semantic segmentation steps use <span>$k$</span>-means to group pixels into water and ice regions. A combination of watershed functions, morphological operations, and further applications of <span>$k$</span>-means are used to identify candidate ice floes. (TBD: Link to main segmentation page)</p><h3 id="Tracking"><a class="docs-heading-anchor" href="#Tracking">Tracking</a><a id="Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking" title="Permalink"></a></h3><p>Ice floe tracking is carried out by comparing the shapes produced in the segmentation step. Shapes with similar area are rotated until the difference in surface area is minimized, and then the edge shapes are compared using a Ѱ-s curve. If thresholds for correlation and area differences are met, then the floe with the best correlation and smallest area differences are considered matches and the objects are assigned the same label. In the end, trajectories for individual floes are recorded in a dataframe.</p><h2 id="Developers"><a class="docs-heading-anchor" href="#Developers">Developers</a><a id="Developers-1"></a><a class="docs-heading-anchor-permalink" href="#Developers" title="Permalink"></a></h2><p>IceFloeTracker.jl is a product of the <a href="https://www.wilhelmuslab.me">Wilhelmus Lab</a> at Brown University, led by Monica M. Wilhelmus. The original algorithm was developed by Rosalinda Lopez-Acosta during her PhD work at University of California Riverside, advised by Dr. Wilhelmus. The translation of the original Matlab code into the current modular, open source Julia package has been carried out in conjunction with the Center for Computing and Visualization at Brown University. Contributors include Daniel Watkins, Maria Isabel Restrepo, Carlos Paniagua, Tim Divoll, John Holland, and Bradford Roarr.</p><h2 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h2><p>If you use IceFloeTracker.jl in research, teaching, or elsewhere, please mention the IceFloeTracker package and cite our journal article outlining the algorithm:</p><p>Lopez-Acosta et al., (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. <em>Remote Sensing of Environment</em>, <strong>234(111406)</strong>, doi:<a href="https://doi.org/10.1016/j.rse.2019.111406">10.1016/j.rse.2019.111406</a>.</p><h2 id="Papers-using-Ice-Floe-Tracker"><a class="docs-heading-anchor" href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a><a id="Papers-using-Ice-Floe-Tracker-1"></a><a class="docs-heading-anchor-permalink" href="#Papers-using-Ice-Floe-Tracker" title="Permalink"></a></h2><ol><li>Manucharyan, Lopez-Acosta, and Wilhelmus (2022)*. Spinning ice floes reveal intensification of mesoscale eddies in the western Arctic Ocean. <em>Scientific Reports</em>, <strong>12(7070)</strong>, doi:<a href="https://doi.org/10.1038/s41598-022-10712-z">10.1038/s41598-022-10712-z</a></li><li>Watkins, Bliss, Hutchings, and Wilhelmus (2023)*. Evidence of Abrupt Transitions Between Sea Ice Dynamical Regimes in the East Greenland Marginal Ice Zone. <em>Geophysical Research Letters</em>, <strong>50(e2023GL103558)</strong>, pp. 1-10, doi:<a href="https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2023GL103558">10.1029/2023GL103558</a></li></ol><p>*Papers using data from the Matlab implementation of Ice Floe Tracker.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Preprocessing-2"><a class="docs-heading-anchor" href="#Preprocessing-2">Preprocessing</a><a class="docs-heading-anchor-permalink" href="#Preprocessing-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}" href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_landmask(input_image, landmask_binary)</code></pre><p>Zero out pixels in all channels of the input image using the binary landmask.</p><p><strong>Arguments</strong></p><ul><li><code>input_image</code>: truecolor RGB image</li><li><code>landmask_binary</code>: binary landmask with 1=land, 0=water/ice</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Preprocessing/landmask.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}" href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_landmask(img, landmask; as_indices::Bool=false)</code></pre><p>Apply the landmask to the input image, optionally returning the indices of non-masked (ocean/ice) pixels.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: input image (e.g., ice mask or RGB image)</li><li><code>landmask</code>: binary landmask (1=ocean/ice, 0=land)</li><li><code>as_indices</code>: if true, return indices of non-masked pixels; otherwise, return masked image</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Preprocessing/landmask.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)" href="#IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.Preprocessing.create_landmask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_landmask(landmask_image, struct_elem, fill_value_lower, fill_value_upper)</code></pre><p>Convert a land mask image to a 1-channel binary matrix, and use a structuring element to extend a buffer to mask complex coastal features, and fill holes in the dilated image. In the resulting mask, land = 0 and ocean = 1. Returns a named tuple with the dilated and non-dilated landmask.</p><p><strong>Arguments</strong></p><ul><li><code>landmask_image</code>: RGB land mask image from <code>fetchdata</code></li><li><code>struct_elem</code>: structuring element for dilation (optional)</li><li><code>fill_value_lower</code>: fill holes having at least these many pixels (optional)</li><li><code>fill_value_upper</code>: fill holes having at most these many pixels (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Preprocessing/landmask.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Preprocessing.make_landmask_se" href="#IceFloeTracker.Preprocessing.make_landmask_se"><code>IceFloeTracker.Preprocessing.make_landmask_se</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_landmask_se()</code></pre><p>Create a structuring element for dilating the landmask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Preprocessing/landmask.jl#L6-L10">source</a></section></article><h3 id="Segmentation-2"><a class="docs-heading-anchor" href="#Segmentation-2">Segmentation</a><a class="docs-heading-anchor-permalink" href="#Segmentation-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}" href="#IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}"><code>IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceDetectionLopezAcosta2019(;
    band_7_threshold::Float64=Float64(5 / 255),
    band_2_threshold::Float64=Float64(230 / 255),
    band_1_threshold::Float64=Float64(240 / 255),
    band_7_threshold_relaxed::Float64=Float64(10 / 255),
    band_1_threshold_relaxed::Float64=Float64(190 / 255),
    possible_ice_threshold::Float64=Float64(75 / 255),
)</code></pre><p>Returns the first non-zero result of two threshold-based and one brightness-peak based ice detections.</p><p>Default thresholds are defined in the published Ice Floe Tracker article: Remote Sensing of the Environment 234 (2019) 111406.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L164-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}" href="#IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}"><code>IceFloeTracker.Segmentation.addlatlon!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addlatlon(pairedfloesdf::DataFrame, refimage::AbstractString)</code></pre><p>Add columns <code>latitude</code>, <code>longitude</code>, and pixel coordinates <code>x</code>, <code>y</code> to <code>pairedfloesdf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pairedfloesdf</code>: dataframe containing floe tracking data.</li><li><code>refimage</code>: path to reference image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/regionprops.jl#L221-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}" href="#IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}"><code>IceFloeTracker.Segmentation.binarize_segments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Find pixels in a segmented image with non-zero labels</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/segmented-image-utilities.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}" href="#IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.convertcentroid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convertcentroid!(propdf, latlondata, colstodrop)</code></pre><p>Convert the centroid coordinates from row and column to latitude and longitude dropping unwanted columns specified in <code>colstodrop</code> for the output data structure. Addionally, add columns <code>x</code> and <code>y</code> with the pixel coordinates of the centroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/regionprops.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}" href="#IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.converttounits!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">converttounits!(propdf, latlondata, colstodrop)</code></pre><p>Convert the floe properties from pixels to kilometers and square kilometers where appropiate. Also drop the columns specified in <code>colstodrop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/regionprops.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{RGB{Float64}}, BitMatrix}" href="#IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{RGB{Float64}}, BitMatrix}"><code>IceFloeTracker.Segmentation.find_ice_labels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_ice_labels(falsecolor_image, landmask; band_7_threshold, band_2_threshold, band_1_threshold, band_7_relaxed_threshold, band_1_relaxed_threshold, possible_ice_threshold)</code></pre><p>Returns pixel indices of likely ice from false color reflectance image, using the thresholds from the Ice Floe Tracker article: Remote Sensing of the Environment 234 (2019) 111406.</p><p><strong>Arguments</strong></p><ul><li><code>falsecolor_image</code>: corrected reflectance false color image - bands [7,2,1]</li><li><code>landmask</code>: bitmatrix landmask for region of interest</li><li><code>band_7_threshold</code>: threshold value used to identify ice in band 7, N0f8(RGB intensity/255)</li><li><code>band_2_threshold</code>: threshold value used to identify ice in band 2, N0f8(RGB intensity/255)</li><li><code>band_1_threshold</code>: threshold value used to identify ice in band 2, N0f8(RGB intensity/255)</li><li><code>band_7_relaxed_threshold</code>: threshold value used to identify ice in band 7 if not found on first pass, N0f8(RGB intensity/255)</li><li><code>band_1_relaxed_threshold</code>: threshold value used to identify ice in band 1 if not found on first pass, N0f8(RGB intensity/255)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L202-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}" href="#IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}"><code>IceFloeTracker.Segmentation.get_ice_masks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ice_masks(
    falsecolor_image,
    morph_residue,
    landmask,
    tiles,
    binarize;
    band_7_threshold,
    band_2_threshold,
    band_1_threshold,
    band_7_threshold_relaxed,
    band_1_threshold_relaxed,
    possible_ice_threshold,
    k
)</code></pre><p>Identifies potential sea ice floes using two methods: selection of a relevant k-means cluster and application of adaptive threshold binarization. For the k-means section, a series of thresholds on band 7, 2, and 1 reflectance  are applied in order to find the cluster containing bright sea ice pixels.</p><p><strong>Arguments</strong></p><ul><li><code>falsecolor_image</code>: MODIS False Color Bands 7-2-1.</li><li><code>morph_residue</code>: Grayscale sharpened and equalized image from preprocessing workflow.</li><li><code>landmask</code>: Binary landmask. </li><li><code>tiles</code>: Iterable with tile divisions.</li><li><code>binarize::Bool=true</code>: Whether to binarize the tiling.</li><li><code>band_7_threshold=5/255</code>: The threshold for band 7.</li><li><code>band_2_threshold=230/255</code>: The threshold for band 2.</li><li><code>band_1_threshold=240/255</code>: The threshold for band 1.</li><li><code>band_7_threshold_relaxed=10</code>: The relaxed threshold for band 7.</li><li><code>band_1_threshold_relaxed=190</code>: The relaxed threshold for band 1.</li><li><code>possible_ice_threshold=75/255</code>: The threshold for possible ice.</li><li><code>k=4</code>: The number of clusters to use for k-means segmentation.</li></ul><p><strong>Returns</strong></p><ul><li>Binary image with likely sea ice floes = 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/ice-masks.jl#L43-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.kmeans_segmentation" href="#IceFloeTracker.Segmentation.kmeans_segmentation"><code>IceFloeTracker.Segmentation.kmeans_segmentation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kmeans_segmentation(gray_image, ice_labels;)</code></pre><p>Apply k-means segmentation to a gray image to isolate a cluster group representing sea ice. Returns a binary image with ice segmented from background.</p><p><strong>Arguments</strong></p><ul><li><code>gray_image</code>: output image from <code>ice-water-discrimination.jl</code> or gray ice floe leads image in <code>segmentation_f.jl</code></li><li><code>ice_labels</code>: vector if pixel coordinates output from <code>find_ice_labels.jl</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/k-means-segmentation.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.regionprops_table" href="#IceFloeTracker.Segmentation.regionprops_table"><code>IceFloeTracker.Segmentation.regionprops_table</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regionprops_table(label_img, intensity_img; properties, connectivity, extra_properties)</code></pre><p>A wrapper of the <code>regionprops_table</code> function from the skimage python library.</p><p>See its full documentation at https://scikit-image.org/docs/stable/api/skimage.measure.html#regionprops-table.</p><p><strong>Arguments</strong></p><ul><li><code>label_img</code>: Image with the labeled objects of interest</li><li><code>intensity_img</code>: (Optional) Used for generating <code>extra_properties</code>, integer/float array from which (presumably) <code>label_img</code> was generated </li><li><code>properties</code>: List (<code>Vector</code> or <code>Tuple</code>) of properties to be generated for each connected component in <code>label_img</code></li><li><code>extra_properties</code>: (Optional) not yet implemented. It will be set to <code>nothing</code></li></ul><p><strong>Notes</strong></p><ul><li>Zero indexing has been corrected for the <code>bbox</code> and <code>centroid</code> properties</li><li><code>bbox</code> data (<code>max_col</code> and <code>max_row</code>) are inclusive</li><li><code>centroid</code> data are rounded to the nearest integer</li></ul><p>See also <a href="@ref"><code>regionprops</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using IceFloeTracker, Random

julia&gt; Random.seed!(123);

julia&gt; bw_img = rand([0, 1], 5, 10)
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  1
 1  0  1  1  1  0  0  0  1  1
 1  1  0  1  1  0  1  0  0  1
 0  1  0  1  0  0  0  0  1  0
 1  0  0  0  0  1  0  1  0  1

julia&gt; label_img = IceFloeTracker.label_components(bw_img, trues(3,3))
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  4
 1  0  1  1  1  0  0  0  4  4
 1  1  0  1  1  0  3  0  0  4
 0  1  0  1  0  0  0  0  4  0
 1  0  0  0  0  2  0  4  0  4

julia&gt; properties = [&quot;area&quot;, &quot;perimeter&quot;]
2-element Vector{String}:
 &quot;area&quot;
 &quot;perimeter&quot;

 julia&gt; IceFloeTracker.regionprops_table(label_img, bw_img, properties = properties)
 4×2 DataFrame
  Row │ area   perimeter 
      │ Int32  Float64   
 ─────┼──────────────────
    1 │    13   11.6213
    2 │     1    0.0
    3 │     1    0.0
    4 │     7    4.62132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/regionprops.jl#L6-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}" href="#IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.Segmentation.segmentation_comparison</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function segmentation<em>comparison(     validated::SegmentedImage, measured::SegmentedImage )::@NamedTuple{recall::Real, precision::Real, F</em>score::Real}</p><p>Compares two SegmentedImages and returns values describing how similar the segmentations are.</p><p>This treats the segment labeled <code>0</code> as background.</p><p>Measures:</p><ul><li>precision: rate at which pixels in <code>validated</code> segments belong to <code>measured</code> segments</li><li>recall: rate at which pixels in <code>measured</code> segments belong to <code>validated</code> segments</li><li>F_score: harmonic mean of precision and recall</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/segmented-image-utilities.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}" href="#IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.tiled_adaptive_binarization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>tiled<em>adaptive</em>binarization(img, tiles; minimum<em>window</em>size=). </p><pre><code class="nohighlight hljs">Applies the (AdaptiveThreshold)[https://juliaimages.org/ImageBinarization.jl/v0.1/#Adaptive-Threshold-1] binarization algorithm
to each tile in the image. Following the recommendations from ImageBinarization, the default is to use the integer window size
nearest to 1/8th the tile size if the tile is large enough. So that the window is large enough to include moderately large floes,
the default minimum window size is 100 pixels (25 km for MODIS imagery). The minimum brightness parameter masks pixels with low
grayscale intensity to prevent dark regions from getting brightened (i.e., the center of a large patch of open water).
The &quot;threshold_percentage&quot; parameter is passed to the the AdaptiveThreshold function (percentage parameter).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L244-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.IceDetectionAlgorithm" href="#IceFloeTracker.Segmentation.IceDetectionAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceDetectionAlgorithm</code></pre><p>Functors to detect ice regions in an image.</p><p>Each algorithm <code>a</code> with parameters <code>kwargs...</code> can be called like:</p><ul><li><code>binarize(image, a(; kwargs...))</code> </li><li>or <code>a(; kwargs...)(image)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721" href="#IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceDetectionBrightnessPeaksMODIS721(;
    band_7_threshold::Real,
    possible_ice_threshold::Real
)(image)
binarize(
    modis_721_image, 
    a::IceDetectionBrightnessPeaksMODIS721
)</code></pre><p>Returns pixels for a MODIS image where (band<em>7 &lt; threshold AND both (band</em>2, band_1) are are above a peak value above some threshold).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm" href="#IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceDetectionFirstNonZeroAlgorithm(;
    algorithms::Vector{IceDetectionAlgorithm},
)(image)
binarize(image, algorithms::IceDetectionFirstNonZeroAlgorithm)</code></pre><p>Runs each algorithm from <code>algorithms</code> on the image, and returns the first which detects any ice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721" href="#IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceDetectionThresholdMODIS721(;
    band_7_threshold::Real,
    band_2_threshold::Real,
    band_1_threshold::Real,
)(image)
binarize(
    modis_721_image, 
    a::IceDetectionThresholdMODIS721
)</code></pre><p>Returns pixels for a MODIS image where (band<em>7 &lt; threshold AND band</em>2 &gt; threshold AND band_1 &gt; threshold).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/find-ice-labels.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.SegmentationComparison" href="#IceFloeTracker.Segmentation.SegmentationComparison"><code>IceFloeTracker.Segmentation.SegmentationComparison</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Results of a segmentation comparison</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/segmented-image-utilities.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Segmentation.SegmentationSummary" href="#IceFloeTracker.Segmentation.SegmentationSummary"><code>IceFloeTracker.Segmentation.SegmentationSummary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Results of a segmentation comparison</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Segmentation/segmented-image-utilities.jl#L46-L48">source</a></section></article><h3 id="Tracking-2"><a class="docs-heading-anchor" href="#Tracking-2">Tracking</a><a class="docs-heading-anchor-permalink" href="#Tracking-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.add_passtimes!-Tuple{Any, Any}" href="#IceFloeTracker.Tracking.add_passtimes!-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.add_passtimes!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_passtimes!(props, passtimes)</code></pre><p>Add a column <code>passtime</code> to each DataFrame in <code>props</code> containing the time of the image in which the floes were captured.</p><p><strong>Arguments</strong></p><ul><li><code>props</code>: array of DataFrames containing floe properties.</li><li><code>passtimes</code>: array of <code>DateTime</code> objects containing the time of the image in which the floes were captured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/tracker.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.addfloemasks!-Tuple{DataFrames.DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}" href="#IceFloeTracker.Tracking.addfloemasks!-Tuple{DataFrames.DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.Tracking.addfloemasks!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addfloemasks!(props::DataFrame, floeimg::FloeLabelsImage)</code></pre><p>Add a column to <code>props</code> called <code>floearray</code> containing the cropped floe masks from <code>floeimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/extended_regionprops.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.adduuid!-Tuple{DataFrames.DataFrame}" href="#IceFloeTracker.Tracking.adduuid!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.adduuid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adduuid!(df::DataFrame)
adduuid!(dfs::Vector{DataFrame})</code></pre><p>Assign a unique ID to each floe in a (vector of) table(s) of floe properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/tracker-funcs.jl#L557-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.addψs!-Tuple{Vector{DataFrames.DataFrame}}" href="#IceFloeTracker.Tracking.addψs!-Tuple{Vector{DataFrames.DataFrame}}"><code>IceFloeTracker.Tracking.addψs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addψs!(props::Vector{DataFrame})</code></pre><p>Add the ψ-s curves to each member of <code>props</code>.</p><p>Note: each member of <code>props</code> must have a <code>mask</code> column with a binary image representing the floe.</p><p>To add floe masks see <a href="#IceFloeTracker.Tracking.addfloemasks!-Tuple{DataFrames.DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>addfloemasks!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/tracker-funcs.jl#L491-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}" href="#IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.align_centroids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Align images by padding so that the centroids of each image are on the edge of or within the same pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}" href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Tracking.bwtraceboundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bwtraceboundary(image::Union{Matrix{Int64},Matrix{Float64},T};
                P0::Union{Tuple{Int,Int},CartesianIndex{2},Nothing}=nothing,
                closed::Bool=true) where T&lt;:AbstractMatrix{Bool}</code></pre><p>Trace the boundary of objects in <code>image</code> </p><p>Background pixels are represented as zero. The algorithm traces the boundary counterclockwise and an initial point <code>P0</code> can be specified. If more than one boundary is detected and an initial point is provided, the boundary that contains this point is returned as a vector of CartesianIndex types. Otherwise an array of vectors is returned with all the detected boundaries in <code>image</code>. </p><p><strong>Arguments</strong></p><ul><li><code>image</code>: image, preferably binary with one single object, whose objects&#39; boundaries are to be traced.</li><li><code>P0</code>: initial point of a target boundary.</li><li><code>closed</code>: if <code>true</code> (default) makes the inital point of a boundary equal to the last point.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(Int, 13, 16); A[2:6, 2:6] .= 1; A[4:8, 7:10] .= 1; A[10:12,13:15] .= 1; A[10:12,3:6] .= 1;

julia&gt; A
13×16 Matrix{Int64}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; boundary = IceFloeTracker.bwtraceboundary(A);

julia&gt; boundary[3]
9-element Vector{CartesianIndex}:
 CartesianIndex(10, 13)
 CartesianIndex(11, 13)
 CartesianIndex(12, 13)
 CartesianIndex(12, 14)
 CartesianIndex(12, 15)
 CartesianIndex(11, 15)
 CartesianIndex(10, 15)
 CartesianIndex(10, 14)
 CartesianIndex(10, 13)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/bwtraceboundary.jl#L6-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}" href="#IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.compute_centroid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the centroid of a binary image. If &#39;rounded&#39;, return the nearest integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}" href="#IceFloeTracker.Tracking.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, props, i)</code></pre><p>Crops the floe delimited by the bounding box data in <code>props</code> at index <code>i</code> from the floe image <code>floesimg</code>.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, but no <code>label</code>, then returns the largest contiguous component.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and a <code>label</code>, then returns the component with the label. In this case, <code>floesimg</code> must be an Array{Int}.</p><p>If the dataframe has only a <code>label</code> and no bounding box data, then returns the component with the label, padded by one cell of zeroes on all sides. In this case, <code>floesimg</code> must be an Array{Int}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/extended_regionprops.jl#L9-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer" href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col)</code></pre><p>Crops the floe delimited by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, from the floe image <code>floesimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/extended_regionprops.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}" href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col, label)</code></pre><p>Crops the floe from <code>floesimg</code> with the label <code>label</code>, returning the region bounded by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and converting to a BitMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/extended_regionprops.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real" href="#IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real"><code>IceFloeTracker.Tracking.crosscorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">r, lags = crosscorr(u::Vector{T},
                    v::Vector{T};
                    normalize::Bool=false,
                    padmode::Symbol=:longest)</code></pre><p>Wrapper of DSP.xcorr with normalization (see https://docs.juliadsp.org/stable/convolutions/#DSP.xcorr)</p><p>Returns the pair <code>(r, lags)</code> with the cross correlation scores <code>r</code> and corresponding <code>lags</code> according to <code>padmode</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u,v</code>: real vectors which could have unequal length.</li><li><code>normalize</code>: return normalized correlation scores (<code>false</code> by default).</li><li><code>padmode</code>: either <code>:longest</code> (default) or <code>:none</code> to control padding of shorter vector with zeros.</li></ul><p><strong>Examples</strong></p><p>The example below builds two vectors, one a shifted version of the other, and computes various cross correlation scores.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 1:5;

julia&gt; x = 0.48.^n;

julia&gt; y = circshift(x,3);

julia&gt; r, lags = crosscorr(x,y,normalize=true);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.369648    -4.0
0.947531    -3.0
0.495695    -2.0
0.3231      -1.0
0.332519     0.0
0.15019      1.0
0.052469     2.0
0.0241435    3.0
0.00941878   4.0

julia&gt; r, lags = crosscorr(x,y,normalize=true,padmode=:none);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.369648    1.0
0.947531    2.0
0.495695    3.0
0.3231      4.0
0.332519    5.0
0.15019     6.0
0.052469    7.0
0.0241435   8.0
0.00941878  9.0</code></pre><p>This final example builds two vectors of different length and computes some cross correlation scores.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 1:5; m = 1:3;

julia&gt; x = 0.48.^n; y = 0.48.^m;

julia&gt; r, lags = crosscorr(x,y,normalize=true);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.0          -4.0
4.14728e-17  -3.0
0.178468     -2.0
0.457473     -1.0
0.994189      0.0
0.477211      1.0
0.229061      2.0
0.105402      3.0
0.0411191     4.0

julia&gt; r, lags = crosscorr(x,y,normalize=true,padmode=:none);

julia&gt; [r lags]
7×2 Matrix{Float64}:
0.178468   1.0
0.457473   2.0
0.994189   3.0
0.477211   4.0
0.229061   5.0
0.105402   6.0
0.0411191  7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/crosscorr.jl#L2-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between two observations in DataFrameRows <code>row1</code> and <code>row2</code>. <code>image_column</code> and <code>time_column</code> specify which columns to use from the DataFrameRows. <code>registration_function</code> is used to compare the two images and should return an angle. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/rotation.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between a measurement in a DataFrameRow <code>measurement</code>, and all the other rows in DataFrame <code>df</code>.</p><ul><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Returns a vector of <code>NamedTuple</code>s with one entry for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows for each comparison <code>row1</code> and <code>row2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/rotation.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between observations in DataFrame <code>df</code>.</p><ul><li><code>id_column</code> is the column with the ID of the image over several observations, e.g. the floe ID.</li><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Each row is compared to each other row in <code>df</code> which are:</p><ul><li>for the same object ID,</li><li>strictly older,</li><li>not older than the previous day.</li></ul><p>Returns a DataFrame with one row for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and all the other values from <code>df</code> with the column name suffix <code>1</code> for the first observation and <code>2</code> for the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/rotation.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}" href="#IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the angle and rotation rate between two images <code>image1</code> and <code>image2</code> at times <code>time1</code> and <code>time2</code>. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>. <code>registration_function</code> is used to compare the two images and should return an angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/rotation.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.get_trajectory_heads-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame" href="#IceFloeTracker.Tracking.get_trajectory_heads-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>IceFloeTracker.Tracking.get_trajectory_heads</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trajectory_heads(pairs)</code></pre><p>Return the last row (most recent member) of each group (trajectory) in <code>pairs</code> as a dataframe.</p><p>This is used for getting the initial floe properties for the next day in search for new pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/tracker-funcs.jl#L530-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}" href="#IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dx, dy = grad(A::Matrix{&lt;:Number})</code></pre><p>Make gradient vector field for the set of points with coordinates in the rows of the matrix <code>A</code> with x-coordinates down column 1 and y-coordinates down column 2. Return a tuple with <code>dx</code> and <code>dy</code> in that order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/psi-s.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}" href="#IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dx, dy = grad(x::Vector{&lt;:Number}, y::Vector{&lt;:Number})</code></pre><p>Make gradient vector field for the set of points with coordinates in vectors <code>x</code> and <code>y</code>. Return a tuple with <code>dx</code> and <code>dy</code> in that order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/psi-s.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.long_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}" href="#IceFloeTracker.Tracking.long_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}"><code>IceFloeTracker.Tracking.long_tracker</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">long_tracker(props, condition_thresholds, mc_thresholds)</code></pre><p>Track ice floes over multiple observations.</p><p>Trajectories are built as follows:</p><ul><li>Assume the floes detected in observation 1 are trajectories of length 1.</li><li>For each subsequent observation:<ul><li>Determine the latest observation for each trajectory – these are the &quot;current trajectory heads&quot;.</li><li>Find matches between the the current trajectory heads and the new observed floes, extending those trajectories.</li><li>Any unmatched floe in an observation is added as a new trajectory starting point.</li></ul></li></ul><p><strong>Arguments</strong></p><ul><li><code>props::Vector{DataFrame}</code>: A vector of DataFrames, each containing ice floe properties for a single day. Each DataFrame must have the following columns:<ul><li>&quot;area&quot;</li><li>&quot;min_row&quot;</li><li>&quot;min_col&quot;</li><li>&quot;max_row&quot;</li><li>&quot;max_col&quot;</li><li>&quot;row_centroid&quot;</li><li>&quot;col_centroid&quot;</li><li>&quot;convex_area&quot;</li><li>&quot;major<em>axis</em>length&quot;</li><li>&quot;minor<em>axis</em>length&quot;</li><li>&quot;orientation&quot;</li><li>&quot;perimeter&quot;</li><li>&quot;mask&quot;: 2D array of booleans</li><li>&quot;passtime&quot;: A timestamp for the floe</li><li>&quot;psi&quot;: the psi-s curve for the floe</li><li>&quot;uuid&quot;: a universally unique identifier for each segmented floe</li></ul></li><li><code>candidate_filter_settings</code>: namedtuple of settings and functions for reducing the number of possible matches. See <code>IceFloeTracker.candidate_filter_settings</code> for sample values.</li><li><code>candidate_matching_settings</code>: settings for area mismatch and psi-s shape correlation. See <code>IceFloeTracker.candidate_matching_settings</code> for sample values.</li></ul><p><strong>Returns</strong></p><p>A DataFrame with the above columns, plus extra columns:</p><ul><li><code>area_mismatch</code> and <code>corr</code>, which are the area mismatch and correlation between a floe and the one that preceeds it in the trajectory. </li><li><code>head_uuid</code>, the floe which was best matched by this floe.</li><li>Trajectories are identified by: <ul><li>a unique identifier <code>ID</code> and the </li><li>UUID of the trajectory, <code>trajectory_uuid</code>.</li></ul></li></ul><p>Note: the props dataframes are modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/long_tracker.jl#L3-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.make_psi_s-Tuple{Matrix{&lt;:Number}}" href="#IceFloeTracker.Tracking.make_psi_s-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.make_psi_s</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_psi_s(XY::Matrix{&lt;:Number};rangeout::Bool=true,
unwrap::Bool=true)</code></pre><p>Alternate method of <code>make_psi_s</code> accepting input vectors <code>x</code> and <code>y</code> as a 2-column matrix <code>[x y]</code> in order to facillitate workflow (output from <code>resample_boundary</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/psi-s.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.make_psi_s-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}" href="#IceFloeTracker.Tracking.make_psi_s-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.make_psi_s</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_psi_s(x::Vector{&lt;:Number},
           y::Vector{&lt;:Number};
           rangeout::Bool=true,
           unwrap::Bool=true)::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Builds the ψ-s curve defined by vectors <code>x</code> and <code>y</code>.</p><p>Returns a tuple of vectors with the phases <code>ψ</code> in the first component and the traversed arclength in the second component. </p><p>Following the convention in [1], the wrapped ψ-s curve has values in [0, 2π) by default; use <code>rangeout</code> to control this behavior.</p><p>See also <a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>bwtraceboundary</code></a>, <a href="#IceFloeTracker.Tracking.resample_boundary"><code>resample_boundary</code></a></p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector of x-coordinates</li><li><code>y</code>: corresponding vector of y-coordinates</li><li><code>rangeout</code>: <code>true</code> (default) for phase values in [0, 2π); <code>false</code> for phase values in (-π, π].</li><li><code>unwrap</code>: set to <code>true</code> to get &quot;unwrapped&quot; phases (default). </li></ul><p><strong>Reference</strong></p><p>[1] McConnell, Ross, et al. &quot;psi-s correlation and dynamic time warping: two methods for tracking ice floes in SAR images.&quot; IEEE Transactions on Geoscience and Remote sensing 29.6 (1991): 1004-1012.</p><p><strong>Example</strong></p><p>The example below builds a cardioid and obtains its ψ-s curve.</p><pre><code class="language-julia-repl hljs">julia&gt; t = range(0,2pi,201);

julia&gt; x = @. cos(t)*(1-cos(t));

julia&gt; y = @. sin(t)*(1-cos(t));

julia&gt; plot(x,y) # visualize the cardioid

julia&gt; psi, s = make_psi_s(x,y);

julia&gt; [s psi] # inspect psi-s data
200×2 Matrix{Float64}:
 0.00049344  0.0314159
 0.0019736   0.0733034
 0.00444011  0.11938
 0.00789238  0.166055
 0.0123296   0.212929
 0.0177505   0.259894
 0.024154    0.306907
 0.0315383   0.35395
 0.0399017   0.401012
 0.0492421   0.448087
 ⋮
 7.96772     9.02377
 7.97511     9.07083
 7.98151     9.11787
 7.98693     9.16488
 7.99137     9.21185
 7.99482     9.25872
 7.99729     9.3054
 7.99877     9.35147
 7.99926     9.39336

 julia&gt; plot(s, psi) # inspect psi-s curve -- should be a straight line from (0, 0) to (8, 3π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/psi-s.jl#L47-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, Any}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}" href="#IceFloeTracker.Tracking.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, Any}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}"><code>IceFloeTracker.Tracking.matchcorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matchcorr(
f1::T,
f2::T,
Δt::F,
mxrot::S=10,
psi::F=0.95,
sz::S=16,
comp::F=0.25,
mm::F=0.22
)
where {T&lt;:AbstractArray{Bool,2},S&lt;:Int64,F&lt;:Float64}</code></pre><p>Compute the mismatch <code>mm</code> and psi-s-correlation <code>c</code> for floes with masks <code>f1</code> and <code>f2</code>.</p><p>The criteria for floes to be considered equivalent is as follows:     - <code>c</code> greater than <code>mm</code>      - <code>_mm</code> is less than <code>mm</code></p><p>A pair of <code>NaN</code> is returned for cases for which one of their mask dimension is too small or their sizes are not comparable.</p><p><strong>Arguments</strong></p><ul><li><code>f1</code>: mask of floe 1</li><li><code>f2</code>: mask of floe 2</li><li><code>Δt</code>: time difference between floes</li><li><code>mxrot</code>: maximum rotation (in degrees) allowed between floes (default: 10)</li><li><code>psi</code>: psi-s-correlation threshold (default: 0.95)</li><li><code>sz</code>: size threshold (default: 16)</li><li><code>comp</code>: size comparability threshold (default: 0.25)</li><li><code>mm</code>: mismatch threshold (default: 0.22)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/matchcorr.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.mismatch" href="#IceFloeTracker.Tracking.mismatch"><code>IceFloeTracker.Tracking.mismatch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mismatch(
    fixed::AbstractArray,
    moving::AbstractArray,
    mxrot::Real,
    step::Real,
)</code></pre><p>Estimate a rotation that minimizes the &#39;mismatch&#39; of aligning <code>moving</code> with <code>fixed</code>.</p><p>Returns a pair with the mismatch score <code>mm</code> and the associated registration angle <code>rot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fixed</code>,<code>moving</code>: images to align via a rigid transformation</li><li><code>mxrot</code>: maximum rotation angle in degrees</li><li><code>step</code>: rotation angle step size in degrees</li></ul><p>The default registration angles are evenly distributed in steps of 5º around a full rotation, ensuring that no angles are repeated (since -180º == +180º).</p><p>Angles are ordered so that smaller absolute angles which are positive will be returned in the event of a tie in the shape difference. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L164-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}" href="#IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>IceFloeTracker.Tracking.mismatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mismatch(
    fixed::AbstractArray,
    moving::AbstractArray,
    test_angles::AbstractArray,
)</code></pre><p>Estimate a rotation that minimizes the &#39;mismatch&#39; of aligning <code>moving</code> with <code>fixed</code>.</p><p>Returns a pair with the mismatch score <code>mm</code> and the associated registration angle <code>rot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fixed</code>,<code>moving</code>: images to align via a rigid transformation</li><li><code>test_angles</code>: candidate angles to check for rotations by, in degrees.  In the case of a tie in the shape difference, the earlier angle from this array will be returned.</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L136-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.register-Tuple{Any, Any}" href="#IceFloeTracker.Tracking.register-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.register</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Finds the image rotation angle in <code>test_angles</code> which minimizes the shape difference between <code>im_reference</code> and <code>im_target</code>. The default test angles are shown in <code>register_default_angles_rad</code>. Use <code>imrotate_function=imrotate_bin_&lt;clockwise|counterclockwise&gt;_&lt;radians|degrees&gt;</code> to get angles &lt;clockwise|counterclockwise&gt; in &lt;radians|degrees&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.resample_boundary" href="#IceFloeTracker.Tracking.resample_boundary"><code>IceFloeTracker.Tracking.resample_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resample_boundary(bd_points::Vector{&lt;:CartesianIndex}, reduc_factor::Int64=2, bd::String=&quot;natural&quot;)</code></pre><p>Get a uniform set of resampled boundary points from <code>bd_points</code> using cubic splines with specified boundary conditions</p><p>The resampled set of points is obtained using parametric interpolation of the points in <code>bd_points</code>. It is assumed that the separation between a pair of adjacent points is 1.</p><p><strong>Arguments</strong></p><ul><li><code>bd_points</code>: Sequetial set of boundary points for the object of interest</li><li><code>reduc_factor</code>: Factor by which to reduce the number of points in <code>bd_points</code> (2 by default)</li></ul><p>-<code>bd</code>: Boundary condition, either &#39;natural&#39; (default) or &#39;periodic&#39;</p><p>See also <a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>bwtraceboundary</code></a></p><p><strong>Example</strong></p><p>```jldoctest; setup = :(using IceFloeTracker) julia&gt; A = zeros(Int, 13, 16); A[2:6, 2:6] .= 1; A[4:8, 7:10] .= 1; A[10:12,13:15] .= 1; A[10:12,3:6] .= 1; julia&gt; A 13×16 Matrix{Int64}:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</p><p>julia&gt; boundary = bwtraceboundary(A);</p><p>julia&gt; boundary[3] 9-element Vector{CartesianIndex}:  CartesianIndex(10, 13)  CartesianIndex(11, 13)  CartesianIndex(12, 13)  CartesianIndex(12, 14)  CartesianIndex(12, 15)  CartesianIndex(11, 15)  CartesianIndex(10, 15)  CartesianIndex(10, 14)  CartesianIndex(10, 13)</p><p>julia&gt; resample_boundary(boundary[3]) 4×2 Matrix{Float64}:  10.0     13.0  12.0357  13.5859  10.5859  15.0357  10.0     13.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/resample-boundary.jl#L3-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}" href="#IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}"><code>IceFloeTracker.Tracking.shape_difference_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Computes the shape difference between im<em>reference and im</em>target for each angle in test<em>angles. The reference image is held constant, while the target image is rotated. The test</em>angles are interpreted as the angle of rotation from target to reference, so to find the best match, we rotate the reverse direction. A perfect match at angle <code>A</code> would imply im<em>target is the same shape as if im</em>reference was rotated by <code>A</code>.  Use <code>imrotate_function=imrotate_bin_&lt;clockwise|counterclockwise&gt;_&lt;radians|degrees&gt;</code> to get angles &lt;clockwise|counterclockwise&gt; in &lt;radians|degrees&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Tracking/register.jl#L73-L80">source</a></section></article><h3 id="Morphology"><a class="docs-heading-anchor" href="#Morphology">Morphology</a><a id="Morphology-1"></a><a class="docs-heading-anchor-permalink" href="#Morphology" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.branch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch(img::AbstractArray{Bool})</code></pre><p>Find branch points in skeletonized image <code>img</code> according to Definition 3 of [1].</p><p>[1] Arcelli, Carlo, and Gabriella Sanniti di Baja. &quot;Skeletons of planar patterns.&quot; Machine Intelligence and Pattern Recognition. Vol. 19. North-Holland, 1996. 99-143.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/branch.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.bridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bridge(bw)</code></pre><p>Set 0-valued pixels to 1 if they have two nonzero neighbors that are not connected. Note the following exceptions:</p><p>0 0 0           0 0 0 1 0 1  becomes  1 1 1 0 0 0           0 0 0</p><p>1 0 1           1 1 1 0 0 0  becomes  0 0 0 0 0 0           0 0 0</p><p>The same applies to all their corresponding rotations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bw = [0 0 0; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 0  0  0
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 0  0  0
 0  0  0
 1  1  1

julia&gt; bw = [1 0 0; 1 0 1; 0 0 1]
3×3 Matrix{Int64}:
 1  0  0
 1  0  1
 0  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  0
 1  1  1
 0  1  1

 julia&gt; bw = [1 0 1; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 1  0  1
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  1
 1  1  1
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/bridge.jl#L23-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.bwareamaxfilt" href="#IceFloeTracker.Morphology.bwareamaxfilt"><code>IceFloeTracker.Morphology.bwareamaxfilt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bwareamaxfilt(bwimg::AbstractArray{Bool}, conn)</code></pre><p>Filter the smaller (by area) connected components in <code>bwimg</code> keeping the (assumed unique) largest.</p><p>Uses 8-pixel connectivity by default (<code>conn=8</code>). Use <code>conn=4</code> for 4-pixel connectivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/bwareamaxfilt.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.hbreak!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hbreak!(img::AbstractArray{Bool})</code></pre><p>Inplace version of <code>hbreak</code>. See also <a href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>hbreak</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/hbreak.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.hbreak-Tuple{Any}" href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>IceFloeTracker.Morphology.hbreak</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hbreak(img::AbstractArray{Bool})</code></pre><p>Remove H-connected pixels in the binary image <code>img</code>. See also <a href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>hbreak!</code></a> for an inplace version of this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; h1 = trues(3,3); h1[[1 3], 2] .= false; h1     
3×3 BitMatrix:    
 1  0  1
 1  1  1
 1  0  1

julia&gt; h2 = trues(3,3); h2[2, [1 3]] .= false; h2     
3×3 BitMatrix:    
 1  1  1
 0  1  0
 1  1  1

julia&gt; hbreak!(h1); h1 # modify h1 inplace
3×3 BitMatrix:
 1  0  1
 1  0  1
 1  0  1

julia&gt; hbreak(h2) 
3×3 BitMatrix:
 1  1  1
 0  0  0
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/hbreak.jl#L24-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.imextendedmin" href="#IceFloeTracker.Morphology.imextendedmin"><code>IceFloeTracker.Morphology.imextendedmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imextendedmin(img)</code></pre><p>Mimics MATLAB&#39;s imextendedmin function that computes the extended-minima transform, which is the regional minima of the H-minima transform. Regional minima are connected components of pixels with a constant intensity value. This function returns a transformed bitmatrix.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: image object</li><li><code>h</code>: suppress minima below this depth threshold</li><li><code>conn</code>: neighborhood connectivity; in 2D 1 = 4-neighborhood and 2 = 8-neighborhood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/minima-transform.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.imregionalmin" href="#IceFloeTracker.Morphology.imregionalmin"><code>IceFloeTracker.Morphology.imregionalmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imregionalmin(img, conn=2)</code></pre><p>Compute the regional minima of the image <code>img</code> using the connectivity <code>conn</code>.</p><p>Returns a bitmatrix of the same size as <code>img</code> with the regional minima.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: Image object</li><li><code>conn</code>: Neighborhood connectivity; in 2D, 1 = 4-neighborhood and 2 = 8-neighborhood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/minima-transform.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})" href="#IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.morph_fill</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">morph_fill(bw::T)::T where {T&lt;:AbstractArray{Bool}}</code></pre><p>Fill holes in binary image <code>bw</code> by setting 0-valued pixels to 1 if they are surrounded by 1-valued pixels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bw = Bool[
        0 0 0 0 0
        0 1 1 1 0
        0 1 0 1 0
        0 1 1 1 0
        0 0 0 0 0
    ];

julia&gt; morph_fill(bw)
5×5 Matrix{Bool}:
 0  0  0  0  0
 0  1  1  1  0
 0  1  1  1  0
 0  1  1  1  0
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/morph-fill.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Morphology.reconstruct" href="#IceFloeTracker.Morphology.reconstruct"><code>IceFloeTracker.Morphology.reconstruct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reconstruct(img, se, type, invert)</code></pre><p>Perform closing/opening by reconstruction on <code>img</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: The input image.</li><li><code>se::AbstractArray</code>: The structuring element.</li><li><code>type::String</code>: The type of morphological operation to perform. Must be either &quot;dilation&quot; (close by reconstruction) or <code>&quot;erosion&quot;</code> (open by reconstruction).</li><li><code>invert::Bool=true</code>: Invert marker and mask before reconstruction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Morphology/reconstruction.jl#L5-L15">source</a></section></article><h3 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}" href="#IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}"><code>IceFloeTracker.Filtering.conditional_histeq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conditional_histeq(
    image,
    clouds_red,
    tiles;
    entropy_threshold::Real=4.0,
    white_threshold::Real=25.5,
    white_fraction_threshold::Real=0.4,
)</code></pre><p>Performs conditional histogram equalization on a true color image.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: The true color image to be equalized.</li><li><code>clouds_red</code>: The land/cloud masked red channel of the false color image.</li><li><code>tiles</code>: the output from <code>get_tiles(image)</code> specifying the tiling to use on the image.</li><li><code>entropy_threshold</code>: The entropy threshold used to determine if a block should be equalized. Default is 4.0.</li><li><code>white_threshold</code>: The white threshold used to determine if a pixel should be considered white. Default is 25.5.</li><li><code>white_fraction_threshold</code>: The white fraction threshold used to determine if a block should be equalized. Default is 0.4.</li></ul><p><strong>Returns</strong></p><p>The equalized true color image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/histogram_equalization.jl#L68-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})" href="#IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})"><code>IceFloeTracker.Filtering.histeq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">histeq(img)
histeq(img; nbins=64)</code></pre><p>Histogram equalization of <code>img</code> using <code>nbins</code> bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/histogram_equalization.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat" href="#IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Filtering.imadjust</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imadjust(img; low, high)</code></pre><p>Adjust the contrast of an image using linear stretching. The image is normalized to [0, 1] and then stretched to the range [low, high].</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: The input image.</li><li><code>low</code>: The lower bound of the stretched image. Default is 0.01.</li><li><code>high</code>: The upper bound of the stretched image. Default is 0.99.</li></ul><p><strong>Returns</strong></p><p>The contrast-adjusted image in the range [0, 255].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/imadjust.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}" href="#IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}"><code>IceFloeTracker.Filtering.nonlinear_diffusion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Perform nonlinear diffusion on an input image. By default, use the Perona-Malik method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/nonlinear_diffusion.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}" href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rgb2gray(rgbchannels::Array{Float64, 3})</code></pre><p>Convert an array of RGB channel data to grayscale in the range [0, 255].</p><p>Identical to MATLAB <code>rgb2gray</code> (https://www.mathworks.com/help/matlab/ref/rgb2gray.html).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/histogram_equalization.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{RGB{Float64}}}" href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{RGB{Float64}}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rgb2gray(img::Matrix{RGB{Float64}})</code></pre><p>Convert an RGB image to grayscale in the range [0, 255].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/histogram_equalization.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.unsharp_mask" href="#IceFloeTracker.Filtering.unsharp_mask"><code>IceFloeTracker.Filtering.unsharp_mask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unsharp_mask(img, radius, amount, threshold)

Enhance image sharpness by weighted differencing of the image and a Gaussian blurred image.
If ``B`` is the blurred version of image ``I``, then an unsharp mask sharpened image is obtained by
``S = I + (I - B)*A``
The amount of sharpening is determined by the factor A. An option threshold can be supplied such
that the sharpening is only applied where ``I - B`` is greater than some factor.

# Arguments
img: input image
radius: standard deviation of the Gaussian blur
amount: multiplicative factor
threshold: minimum difference for applying the sharpening

# Returns
Sharpened image</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/unsharp_mask.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}" href="#IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}"><code>IceFloeTracker.Filtering.unsharp_mask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unsharp_mask(image_gray, smoothing_param, intensity, clampmax)</code></pre><p>Apply unsharp masking on (equalized) grayscale ([0, <code>clampmax</code>]) image to enhance its sharpness.</p><p><strong>Arguments</strong></p><ul><li><code>image_gray</code>: The input grayscale image, typically already equalized.</li><li><code>smoothing_param::Int</code>: The pixel radius for Gaussian blurring (typically between 1 and 10).</li><li><code>intensity</code>: The amount of sharpening to apply. Higher values result in more pronounced sharpening.</li><li><code>clampmax</code>: upper limit of intensity values in the returned image.`</li></ul><p><strong>Returns</strong></p><p>The sharpened grayscale image with values clipped between 0 and <code>clapmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Filtering/unsharp_mask.jl#L61-L73">source</a></section></article><h3 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Data.ValidationDataLoader" href="#IceFloeTracker.Data.ValidationDataLoader"><code>IceFloeTracker.Data.ValidationDataLoader</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Loader for validated ice floe data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Data/Data.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Data.Watkins2025GitHub" href="#IceFloeTracker.Data.Watkins2025GitHub"><code>IceFloeTracker.Data.Watkins2025GitHub</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Watkins2025GitHub(; ref)()
Watkins2025GitHub(; ref, [url, dataset_metadata_path, cache_dir])(; [case_filter])</code></pre><p>Loader for validated ice floe data from <a href="https://github.com/danielmwatkins/ice_floe_validation_dataset">the Watkins 2025 Ice Floe Validation Dataset</a>.</p><p>Struct fields: </p><ul><li><code>url</code>: URL of the GitHub repository with the dataset</li><li><code>ref</code>: <code>git</code> ref of the commit from which to load the data</li><li><code>dataset_metadata_path</code>: path within the repository to a CSV file describing the data</li><li><code>cache_dir</code>: local path where the data will be stored.</li></ul><p>Cacheing:  Data are downloaded to the <code>ref</code> subdirectory of <code>cache_dir</code>, e.g. <code>/tmp/Watkins2025/main</code>.  If a file of the correct name already exists in that path, if loaded again the cached data will be returned. If the data change in the source for that ref, the loader won&#39;t load the new data. In that case, it&#39;s necessary to delete the cached file. A better choice is to use a specific revision <code>ref</code>: either a tag, or a commit ID.</p><p>Function arguments:</p><ul><li><code>case_filter</code>: function run on each metadata entry;    if it returns true, then the data from that case is returned </li></ul><p>Function returns a named tuple with these fields:</p><ul><li><code>metadata</code>: DataFrame of the cases which passed the <code>case_filter</code></li><li><code>data</code>: Generator which returns a <code>ValidationDataCase</code> for each case which passed the <code>case_filter</code></li></ul><p>Example:</p><pre><code class="language-julia-repl hljs">julia&gt; data_loader = Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)
julia&gt; dataset = data_loader(;case_filter=c -&gt; (
                        c.visible_floes == &quot;yes&quot; &amp;&amp;
                        c.cloud_category_manual == &quot;none&quot; &amp;&amp;
                        c.artifacts == &quot;no&quot;
                    ));
julia&gt; dataset.metadata
8×28 DataFrame
    Row │ case_number  region        start_date  center_lon  center_lat  center_x  center_y  month  sea_ice_fr ⋯
        │ Int64        String31      Date        Float64     Float64     Int64     Int64     Int64  Float64    ⋯
   ─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────
      1 │          11  baffin_bay    2011-07-02    -70.7347     72.3303   -837500  -1737500      7             ⋯
      2 │          14  baffin_bay    2022-07-06    -69.0755     72.3157   -787500  -1762500      7
      3 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
      4 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
      5 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5             ⋯
      6 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5
      7 │         128  hudson_bay    2019-04-15    -91.9847     57.853   -2612500  -2437500      4
      8 │         166  laptev_sea    2016-09-04    136.931      79.7507    -37500   1112500      9
                                                                                        20 columns omitted

julia&gt; first(dataset.data)
ValidationDataCase(&quot;011-baffin_bay-100km-20110702-aqua-250m&quot;, Dict{Symbol, Any}(:sea_ice_fraction =&gt; 0.8, :vi...

julia&gt; first(dataset.data).validated_labeled_floes
Segmented Image with:
labels map: 400×400 Matrix{Int64}
number of labels: 105</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Data/Data.jl#L40-L100">source</a></section></article><h3 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Utils.@persist" href="#IceFloeTracker.Utils.@persist"><code>IceFloeTracker.Utils.@persist</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@persist img fname
@persist(img,fname)
@persist img
@persist(img)
@persist img fname ts
@persist(img, fname, ts)</code></pre><p>Given a reference to an image object <code>img</code>, the macro persists (saves to a file) <code>img</code> to the current working directory using <code>fname</code> as filename. Returns <code>img</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: Symbol expression representing an image object loaded in memory.</li><li><code>fname</code>: Optional filename for the persisted image.</li><li><code>ts</code>: Optional boolean to attach timestamp to <code>fname</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/Utils/Utils.jl#L8-L22">source</a></section></article><h3 id="Unsorted-Functions"><a class="docs-heading-anchor" href="#Unsorted-Functions">Unsorted Functions</a><a id="Unsorted-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Unsorted-Functions" title="Permalink"></a></h3><div class="admonition is-todo" id="Functions-here-still-need-to-be-sorted-a95331db826fba93"><header class="admonition-header">Functions here still need to be sorted<a class="admonition-anchor" href="#Functions-here-still-need-to-be-sorted-a95331db826fba93" title="Permalink"></a></header><div class="admonition-body"><p>The functions which are shown in this section  will be reorganized into submodules.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.callable_store-Tuple{}" href="#IceFloeTracker.callable_store-Tuple{}"><code>IceFloeTracker.callable_store</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">callable_store()</code></pre><p>Create a store and a callback function to add key-value pairs to the store.</p><p>Returns a <code>store::Dict</code> and a <code>callback::Function</code> which stores any kwargs passed to it in the <code>store</code>.</p><p><strong>Examples</strong></p><p>Basic usage is to store values using the callback function</p><pre><code class="language-julia-repl hljs">julia&gt; store, callback = callable_store()
julia&gt; store
Dict{Any, Any}()

julia&gt; callback(;foo=&quot;bar&quot;)  # echoes the updated store
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;

julia&gt; store  # values are available from the store object
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;</code></pre><p>A real-world use case is to extract data from a segmentation algorithm run:</p><pre><code class="language-julia-repl hljs">julia&gt; intermediate_results, intermediate_results_callback = callable_store()
julia&gt; data = first(Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)());
julia&gt; segments = LopezAcosta2019Tiling()(
    data.modis_truecolor,
    data.modis_falsecolor,
    data.modis_landmask;
    intermediate_results_callback,
)
Segmented Image with:
  labels map: 400×400 Matrix{Int64}
  number of labels: 12

julia&gt; intermediate_data
Dict{Any, Any} with 16 entries:
  :binarized_tiling                       =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :icemask                                =&gt; Bool[1 1 … 1 1; 1 1 … 1 1; … ; 0 0 … 1 1; 0 0 … 1 1]
  :equalized_gray                         =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :morphed_residue                        =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :L0mask                                 =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :segmented                              =&gt; Segmented Image with:…
  :prelim_icemask2                        =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :equalized_gray_sharpened_reconstructed =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :gammagreen                             =&gt; [190.35 190.23 … 182.93 185.03; 191.68 190.6 … 185.04 192.08; … ; 163.87 173.33 … 108.02 108.18; 166.14 173.3 … 112.35 112.32]
  :segment_mask                           =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :ref_img_cloudmasked                    =&gt; RGB{N0f8}[RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.008,0.706,0.761) RGB{N0f8}(0.0,0.722,0.769); RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.039,0.702,0.784) RGB{N0f8}(0.075,0.784,0.859); … ; RGB{…
  :prelim_icemask                         =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :equalized_gray_reconstructed           =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :final                                  =&gt; Bool[0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 1 0; 0 0 … 0 0]
  :local_maxima_mask                      =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :labeled                                =&gt; [0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 9 0; 0 0 … 0 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/utils.jl#L81-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.create_cloudmask" href="#IceFloeTracker.create_cloudmask"><code>IceFloeTracker.create_cloudmask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_cloudmask(img, f::AbstractCloudMaskAlgorithm)</code></pre><p>Cloud masks in the IFT are BitMatrix objects such that for an image I and cloudmask C, cloudy pixels can be selected by I[C], and clear-sky pixels can be selected with I[.!C]. Construction of a cloud mask uses the syntax</p><pre><code class="language-julia hljs">f = CloudMaskAlgorithm(parameters)
C = create_cloudmask(img; CloudMaskAlgorithm)</code></pre><p>By default, <code>create_cloudmask</code> uses the algorithm found in [1]. This algorithm converts a 3-channel MODIS 7-2-1 false color image into a 1-channel binary matrix in which clouds = 1 and anything else = 0. The algorithm aims to identify patches of opaque cloud while allowing thin and transparent cloud to remain. This algorithm is instantiated using</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask()</code></pre><p>In this case, the default values are applied. It can also called using a set of customized parameters. These values must be real numbers between 0 and 1. To reproduce the default parameters, you may call</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=110/255, band_7_threshold=200/255, band_2_threshold=190/255, ratio_lower=0.0, ratio_upper=0.75).</code></pre><p>A stricter cloud mask was defined in [2], covering more cloudy pixels while minimally impacting the masking of cloud-covered ice pixels.</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=53/255, band_7_threshold=130/255, band_2_threshold=169/255, ratio_lower=0.0, ratio_upper=0.53).</code></pre><p>These parameters together define a piecewise linear partition of pixels based on their Band 7 and Band 2 callibrated reflectance. Pixels with intensity above <code>prelim_threshold</code> are considered as potential cloudy pixels. Then, pixels with Band 7 reflectance less than <code>band_7_threshold</code>, Band 2 reflectance greater than <code>band_2_threshold</code>, and Band 7 to Band 2 ratios between <code>ratio_lower</code> and <code>ratio_upper</code> are removed from the cloud mask (i.e., set to cloud-free).</p><p><strong>Arguments</strong></p><ul><li><code>false_color_image</code>: corrected reflectance false color image - bands [7,2,1]</li><li><code>prelim_threshold</code>: threshold value used to identify clouds in band 7, N0f8(RGB intensity/255)</li><li><code>band_7_threshold</code>: threshold value used to identify cloud-ice in band 7, N0f8(RGB intensity/255)</li><li><code>band_2_threshold</code>: threshold value used to identify cloud-ice in band 2, N0f8(RGB intensity/255)</li><li><code>ratio_lower</code>: threshold value used to set lower ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_upper</code>: threshold value used to set upper ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_offset</code>: offset value used to adjust the upper ratio of cloud-ice in bands 7 and 2</li></ul><ol><li>Lopez-Acosta, R., Schodlok, M. P., &amp; Wilhelmus, M. M. (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. Remote Sensing of Environment, 234(111406), 1–15. (https://doi.org/10.1016/j.rse.2019.111406)[https://doi.org/10.1016/j.rse.2019.111406]</li><li>Watkins, D.M., Kim, M., Paniagua, C., Divoll, T., Holland, J.G., Hatcher, S., Hutchings, J.K., and Wilhelmus, M.M. (in prep). Calibration and validation of the Ice Floe Tracker algorithm. </li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/cloudmask.jl#L159-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.imsharpen" href="#IceFloeTracker.imsharpen"><code>IceFloeTracker.imsharpen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imsharpen(truecolor_image, landmask_no_dilate, lambda, kappa, niters, nbins, rblocks, cblocks, clip, smoothing_param, intensity)</code></pre><p>Sharpen <code>truecolor_image</code>.</p><p><strong>Arguments</strong></p><ul><li><code>truecolor_image</code>: input image in truecolor</li><li><code>landmask_no_dilate</code>: landmask for region of interest</li><li><code>lambda</code>: speed of diffusion (0–0.25)</li><li><code>kappa</code>: conduction coefficient for diffusion (25–100)</li><li><code>niters</code>: number of iterations of diffusion</li><li><code>nbins</code>: number of bins during histogram equalization</li><li><code>rblocks</code>: number of row blocks to divide input image during equalization</li><li><code>cblocks</code>: number of column blocks to divide input image during equalization</li><li><code>clip</code>: Thresholds for clipping histogram bins (0–1); values closer to one minimize contrast enhancement, values closer to zero maximize contrast enhancement</li><li><code>smoothing_param</code>: pixel radius for gaussian blurring (1–10)</li><li><code>intensity</code>: amount of sharpening to perform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/normalization.jl#L63-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.loadimg-Tuple{}" href="#IceFloeTracker.loadimg-Tuple{}"><code>IceFloeTracker.loadimg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadimg(; dir::String, fname::String)</code></pre><p>Load an image from <code>dir</code> with filename <code>fname</code> into a matrix of <code>Float64</code> values. Returns the loaded image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}" href="#IceFloeTracker.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.LopezAcostaCloudMask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>LopezAcostaCloudMask(prelim<em>threshold, band</em>7<em>threshold, band</em>2<em>threshold, ratio</em>lower, ratio<em>offset, ratio</em>upper)</p><p>AbstractCloudMaskAlgorithm implementation of the cloud mask from Lopez-Acosta et al. 2019. Cloud masks algorithms are initialized with a set of parameters, then can be supplied to <code>create_cloudmask</code> as an argument. The Lopez-Acosta et al. cloudmask creates a piecewise linear bifurcation of band 2 and band 7 brightness in a MODIS 7-2-1 false color image using a sequence of thresholds on band 2 and band 7 and on the ratio of band 7 to band 2 brightness. </p><p>Example:</p><pre><code class="nohighlight hljs">using IceFloeTracker
using IceFloeTracker: Watkins2025GitHub

data_loader = Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)
case = first(data_loader(c -&gt; (c.case_number == 6 &amp;&amp; c.satellite == &quot;terra&quot;)))
cm_algo = LopezAcostaCloudMask()
cloud_mask = create_cloudmask(case.modis_falsecolor, cm_algo)

# show image:
Gray.(cloud_mask)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/cloudmask.jl#L30-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IceFloeTracker.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}" href="#IceFloeTracker.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Watkins2025CloudMask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Watkins2025CloudMask(prelim<em>threshold, band</em>7<em>threshold, band</em>2<em>threshold, ratio</em>lower, ratio<em>offset, ratio</em>upper, marker<em>strel, opening</em>strel)</p><p>Extension of the Lopez-Acosta et al. 2019 with parameters calibrated to the Ice Floe Validation Dataset. The Lopez-Acosta et al. cloudmask creates a piecewise linear bifurcation of band 2 and band 7 brightness  in a MODIS 7-2-1 false color image using a sequence of thresholds on band 2 and band 7 and on the ratio of band 7 to band 2 brightness. This extension first creates a cloud mask using the LopezAcostaCloudMask, then applies morphological operations to remove speckle and smooth boundaries.</p><p>Example:</p><pre><code class="nohighlight hljs">using IceFloeTracker
using IceFloeTracker: Watkins2025GitHub

data_loader = Watkins2025GitHub(; ref=&quot;a451cd5e62a10309a9640fbbe6b32a236fcebc70&quot;)
case = first(data_loader(c -&gt; (c.case_number == 6 &amp;&amp; c.satellite == &quot;terra&quot;)))
cm_algo = Watkins2025CloudMask()
cloud_mask = create_cloudmask(case.modis_falsecolor, cm_algo)

# show image:
Gray.(cloud_mask)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/002f1435df42611087d0e3a611260cdf5a08062b/src/cloudmask.jl#L113-L136">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#IceFloeTracker.Data.ValidationDataLoader"><code>IceFloeTracker.Data.ValidationDataLoader</code></a></li><li><a href="#IceFloeTracker.Data.Watkins2025GitHub"><code>IceFloeTracker.Data.Watkins2025GitHub</code></a></li><li><a href="#IceFloeTracker.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.LopezAcostaCloudMask</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionAlgorithm</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721</code></a></li><li><a href="#IceFloeTracker.Segmentation.SegmentationComparison"><code>IceFloeTracker.Segmentation.SegmentationComparison</code></a></li><li><a href="#IceFloeTracker.Segmentation.SegmentationSummary"><code>IceFloeTracker.Segmentation.SegmentationSummary</code></a></li><li><a href="#IceFloeTracker.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Watkins2025CloudMask</code></a></li><li><a href="#IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}"><code>IceFloeTracker.Filtering.conditional_histeq</code></a></li><li><a href="#IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})"><code>IceFloeTracker.Filtering.histeq</code></a></li><li><a href="#IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Filtering.imadjust</code></a></li><li><a href="#IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}"><code>IceFloeTracker.Filtering.nonlinear_diffusion</code></a></li><li><a href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{RGB{Float64}}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a></li><li><a href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a></li><li><a href="#IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}"><code>IceFloeTracker.Filtering.unsharp_mask</code></a></li><li><a href="#IceFloeTracker.Filtering.unsharp_mask"><code>IceFloeTracker.Filtering.unsharp_mask</code></a></li><li><a href="#IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.branch</code></a></li><li><a href="#IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.bridge</code></a></li><li><a href="#IceFloeTracker.Morphology.bwareamaxfilt"><code>IceFloeTracker.Morphology.bwareamaxfilt</code></a></li><li><a href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>IceFloeTracker.Morphology.hbreak</code></a></li><li><a href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.hbreak!</code></a></li><li><a href="#IceFloeTracker.Morphology.imextendedmin"><code>IceFloeTracker.Morphology.imextendedmin</code></a></li><li><a href="#IceFloeTracker.Morphology.imregionalmin"><code>IceFloeTracker.Morphology.imregionalmin</code></a></li><li><a href="#IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.morph_fill</code></a></li><li><a href="#IceFloeTracker.Morphology.reconstruct"><code>IceFloeTracker.Morphology.reconstruct</code></a></li><li><a href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.Preprocessing.create_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.make_landmask_se"><code>IceFloeTracker.Preprocessing.make_landmask_se</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}"><code>IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019</code></a></li><li><a href="#IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}"><code>IceFloeTracker.Segmentation.addlatlon!</code></a></li><li><a href="#IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}"><code>IceFloeTracker.Segmentation.binarize_segments</code></a></li><li><a href="#IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.convertcentroid!</code></a></li><li><a href="#IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.converttounits!</code></a></li><li><a href="#IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{RGB{Float64}}, BitMatrix}"><code>IceFloeTracker.Segmentation.find_ice_labels</code></a></li><li><a href="#IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}"><code>IceFloeTracker.Segmentation.get_ice_masks</code></a></li><li><a href="#IceFloeTracker.Segmentation.kmeans_segmentation"><code>IceFloeTracker.Segmentation.kmeans_segmentation</code></a></li><li><a href="#IceFloeTracker.Segmentation.regionprops_table"><code>IceFloeTracker.Segmentation.regionprops_table</code></a></li><li><a href="#IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.Segmentation.segmentation_comparison</code></a></li><li><a href="#IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.tiled_adaptive_binarization</code></a></li><li><a href="#IceFloeTracker.Tracking.add_passtimes!-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.add_passtimes!</code></a></li><li><a href="#IceFloeTracker.Tracking.addfloemasks!-Tuple{DataFrames.DataFrame, Union{BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.Tracking.addfloemasks!</code></a></li><li><a href="#IceFloeTracker.Tracking.adduuid!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.adduuid!</code></a></li><li><a href="#IceFloeTracker.Tracking.addψs!-Tuple{Vector{DataFrames.DataFrame}}"><code>IceFloeTracker.Tracking.addψs!</code></a></li><li><a href="#IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.align_centroids</code></a></li><li><a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Tracking.bwtraceboundary</code></a></li><li><a href="#IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.compute_centroid</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Tuple{Union{BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real"><code>IceFloeTracker.Tracking.crosscorr</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_trajectory_heads-Tuple{T} where T&lt;:DataFrames.AbstractDataFrame"><code>IceFloeTracker.Tracking.get_trajectory_heads</code></a></li><li><a href="#IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a></li><li><a href="#IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a></li><li><a href="#IceFloeTracker.Tracking.long_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}"><code>IceFloeTracker.Tracking.long_tracker</code></a></li><li><a href="#IceFloeTracker.Tracking.make_psi_s-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.make_psi_s</code></a></li><li><a href="#IceFloeTracker.Tracking.make_psi_s-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.make_psi_s</code></a></li><li><a href="#IceFloeTracker.Tracking.matchcorr-Union{Tuple{F}, Tuple{S}, Tuple{T}, Tuple{T, T, Any}} where {T&lt;:AbstractMatrix{Bool}, S&lt;:Int64, F&lt;:Float64}"><code>IceFloeTracker.Tracking.matchcorr</code></a></li><li><a href="#IceFloeTracker.Tracking.mismatch"><code>IceFloeTracker.Tracking.mismatch</code></a></li><li><a href="#IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>IceFloeTracker.Tracking.mismatch</code></a></li><li><a href="#IceFloeTracker.Tracking.register-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.register</code></a></li><li><a href="#IceFloeTracker.Tracking.resample_boundary"><code>IceFloeTracker.Tracking.resample_boundary</code></a></li><li><a href="#IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}"><code>IceFloeTracker.Tracking.shape_difference_rotation</code></a></li><li><a href="#IceFloeTracker.callable_store-Tuple{}"><code>IceFloeTracker.callable_store</code></a></li><li><a href="#IceFloeTracker.create_cloudmask"><code>IceFloeTracker.create_cloudmask</code></a></li><li><a href="#IceFloeTracker.imsharpen"><code>IceFloeTracker.imsharpen</code></a></li><li><a href="#IceFloeTracker.loadimg-Tuple{}"><code>IceFloeTracker.loadimg</code></a></li><li><a href="#IceFloeTracker.Utils.@persist"><code>IceFloeTracker.Utils.@persist</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="preprocessing/">Preprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 28 October 2025 20:48">Tuesday 28 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
