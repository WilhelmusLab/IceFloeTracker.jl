<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IceFloeTracker.jl · IceFloeTracker.jl</title><meta name="title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="og:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta property="twitter:title" content="IceFloeTracker.jl · IceFloeTracker.jl"/><meta name="description" content="Documentation for IceFloeTracker.jl."/><meta property="og:description" content="Documentation for IceFloeTracker.jl."/><meta property="twitter:description" content="Documentation for IceFloeTracker.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="IceFloeTracker.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>IceFloeTracker.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>IceFloeTracker.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Algorithm-components"><span>Algorithm components</span></a></li><li><a class="tocitem" href="#Developers"><span>Developers</span></a></li><li><a class="tocitem" href="#Citing"><span>Citing</span></a></li><li><a class="tocitem" href="#Papers-using-Ice-Floe-Tracker"><span>Papers using Ice Floe Tracker</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="segmentation/">Segmentation</a></li><li><a class="tocitem" href="tracking/">Tracking</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/lopez-acosta-2019-workflow/">Segmentation Algorithm Workflows</a></li><li><a class="tocitem" href="tutorials/segmentation-tracking/">Ice Floe Segmentation and Tracking Algorithm</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IceFloeTracker.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/main/docs/prebuild/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IceFloeTracker.jl"><a class="docs-heading-anchor" href="#IceFloeTracker.jl">IceFloeTracker.jl</a><a id="IceFloeTracker.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IceFloeTracker.jl" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>IceFloeTracker.jl is a collection of routines and tools for processing remote sensing imagery, identifying sea ice floes, and tracking the displacement and rotation of ice floes across multiple images. It can be used either standalone to create custom processing pathways or with the <a href="https://github.com/WilhelmusLab/ice-floe-tracker-pipeline">Ice Floe Tracker Pipeline</a>.</p><ul><li><a href="#IceFloeTracker.jl">IceFloeTracker.jl</a></li><li class="no-marker"><ul><li><a href="#Overview">Overview</a></li><li><a href="#Algorithm-components">Algorithm components</a></li><li><a href="#Developers">Developers</a></li><li><a href="#Citing">Citing</a></li><li><a href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a></li><li><a href="#API-Reference">API Reference</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="preprocessing/#Preprocessing">Preprocessing</a></li><li class="no-marker"><ul><li><a href="preprocessing/#Land-masks">Land masks</a></li><li><a href="preprocessing/#Cloud-masks">Cloud masks</a></li><li><a href="preprocessing/#Image-regularization">Image regularization</a></li></ul></li><li><a href="segmentation/#Segmentation">Segmentation</a></li><li class="no-marker"><ul><li><a href="segmentation/#Ice/Water-Discrimination">Ice/Water Discrimination</a></li><li><a href="segmentation/#Feature-Identification">Feature Identification</a></li></ul></li><li><a href="tracking/#Tracking">Tracking</a></li><li class="no-marker"><ul><li><a href="tracking/#Preparing-data-for-tracking">Preparing data for tracking</a></li><li><a href="tracking/#Floe-Filter-Functions">Floe Filter Functions</a></li><li><a href="tracking/#Matching-Function">Matching Function</a></li></ul></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Segmentation-Algorithm-Workflows">Segmentation Algorithm Workflows</a></li><li class="no-marker"><ul><li><a href="tutorials/lopez-acosta-2019-workflow/#Load-the-images">Load the images</a></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Run-the-segmentation-algorithm">Run the segmentation algorithm</a></li><li><a href="tutorials/lopez-acosta-2019-workflow/#Run-the-segmentation-algorithm-with-tiling">Run the segmentation algorithm with tiling</a></li></ul></li><li><a href="tutorials/segmentation-tracking/#Ice-Floe-Segmentation-and-Tracking-Algorithm">Ice Floe Segmentation and Tracking Algorithm</a></li><li><a href="tutorials/segmentation-tracking/#Identify-Sea-Ice-Floes">Identify Sea Ice Floes</a></li><li><a href="tutorials/segmentation-tracking/#Tracking-Algorithm">Tracking Algorithm</a></li><li><a href="tutorials/segmentation-tracking/#Visualizing-the-results">Visualizing the results</a></li><li><a href="tutorials/segmentation-tracking/#Next-steps">Next steps</a></li></ul><h2 id="Algorithm-components"><a class="docs-heading-anchor" href="#Algorithm-components">Algorithm components</a><a id="Algorithm-components-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-components" title="Permalink"></a></h2><p>The Ice Floe Tracker (IFT) package includes the core functions for the three main steps of the algorithm. These functions can be used independently and can be customized for specific use cases. </p><h3 id="Preprocessing"><a class="docs-heading-anchor" href="#Preprocessing">Preprocessing</a><a id="Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing" title="Permalink"></a></h3><p>IFT operates on optical satellite imagery. The main functions are designed with &quot;true color&quot; and &quot;false color&quot; imagery in mind, and have thus far primarily been tested on imagery from the Moderate Resolution Imaging Spectroradiometer (MODIS) from the NASA <em>Aqua</em> and <em>Terra</em> satellites. The preprocessing routines mask land and cloud features, and aim to adjust and sharpen the remainder of the images to amplify the contrast along the edges of sea ice floes. (TBD: Link to main preprocessing page)</p><h3 id="Segmentation"><a class="docs-heading-anchor" href="#Segmentation">Segmentation</a><a id="Segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Segmentation" title="Permalink"></a></h3><p>The IFT segmentation functions include functions for semantic segmentation (pixel-by-pixel assignment into predefined categories) and object-based segmentation (groupings of pixels into distinct objects). The semantic segmentation steps use <span>$k$</span>-means to group pixels into water and ice regions. A combination of watershed functions, morphological operations, and further applications of <span>$k$</span>-means are used to identify candidate ice floes. (TBD: Link to main segmentation page)</p><h3 id="Tracking"><a class="docs-heading-anchor" href="#Tracking">Tracking</a><a id="Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking" title="Permalink"></a></h3><p>Ice floe tracking is carried out by comparing the shapes produced in the segmentation step. Shapes with similar area are rotated until the difference in surface area is minimized, and then the edge shapes are compared using a Ѱ-s curve. If thresholds for correlation and area differences are met, then the floe with the best correlation and smallest area differences are considered matches and the objects are assigned the same label. In the end, trajectories for individual floes are recorded in a dataframe.</p><h2 id="Developers"><a class="docs-heading-anchor" href="#Developers">Developers</a><a id="Developers-1"></a><a class="docs-heading-anchor-permalink" href="#Developers" title="Permalink"></a></h2><p>IceFloeTracker.jl is a product of the <a href="https://www.wilhelmuslab.me">Wilhelmus Lab</a> at Brown University, led by Monica M. Wilhelmus. The original algorithm was developed by Rosalinda Lopez-Acosta during her PhD work at University of California Riverside, advised by Dr. Wilhelmus. The translation of the original Matlab code into the current modular, open source Julia package has been carried out in conjunction with the Center for Computing and Visualization at Brown University. Contributors include Daniel Watkins, Maria Isabel Restrepo, Carlos Paniagua, Tim Divoll, John Holland, and Bradford Roarr.</p><h2 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h2><p>If you use IceFloeTracker.jl in research, teaching, or elsewhere, please mention the IceFloeTracker package and cite our journal article outlining the algorithm:</p><p>Lopez-Acosta et al., (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. <em>Remote Sensing of Environment</em>, <strong>234(111406)</strong>, doi:<a href="https://doi.org/10.1016/j.rse.2019.111406">10.1016/j.rse.2019.111406</a>.</p><h2 id="Papers-using-Ice-Floe-Tracker"><a class="docs-heading-anchor" href="#Papers-using-Ice-Floe-Tracker">Papers using Ice Floe Tracker</a><a id="Papers-using-Ice-Floe-Tracker-1"></a><a class="docs-heading-anchor-permalink" href="#Papers-using-Ice-Floe-Tracker" title="Permalink"></a></h2><ol><li>Manucharyan, Lopez-Acosta, and Wilhelmus (2022)*. Spinning ice floes reveal intensification of mesoscale eddies in the western Arctic Ocean. <em>Scientific Reports</em>, <strong>12(7070)</strong>, doi:<a href="https://doi.org/10.1038/s41598-022-10712-z">10.1038/s41598-022-10712-z</a></li><li>Watkins, Bliss, Hutchings, and Wilhelmus (2023)*. Evidence of Abrupt Transitions Between Sea Ice Dynamical Regimes in the East Greenland Marginal Ice Zone. <em>Geophysical Research Letters</em>, <strong>50(e2023GL103558)</strong>, pp. 1-10, doi:<a href="https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2023GL103558">10.1029/2023GL103558</a></li></ol><p>*Papers using data from the Matlab implementation of Ice Floe Tracker.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.BenkridCrookes"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.BenkridCrookes"><code>IceFloeTracker.Segmentation.BenkridCrookes</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>BenkridCrookes(connectivity=4)</p><p>Functor producing a BenkridCrookes PerimeterEstimationAlgorithm. The connectivity used for the erosion is the only parameter. The algorithm uses strel<em>diamond((3,3)) for 4-connectivity and strel</em>box((3,3)) for 8-connectivity. The resulting function operates on a binary array, which  is assumed to contain a single object.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; A = [0 1 1; 1 1 1; 1 1 1];

julia&gt; BenkridCrookes(connectivity=4)(A)
7.414213562373095

julia&gt; BenkridCrookes(connectivity=8)(A)
7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L204-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.IceDetectionAlgorithm"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.IceDetectionAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IceDetectionAlgorithm</code></pre><p>Functors to detect ice regions in an image.</p><p>Each algorithm <code>a</code> with parameters <code>kwargs...</code> can be called like:</p><ul><li><code>binarize(image, a(; kwargs...))</code> </li><li>or <code>a(; kwargs...)(image)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L50-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IceDetectionBrightnessPeaksMODIS721(;
    band_7_max::Real,
    possible_ice_threshold::Real
    nbins=64
    minimum_prominence=0.01
    window_size=3
)

binarize(modis_721_image, a::IceDetectionBrightnessPeaksMODIS721)</code></pre><p>Uses the histogram of the band 1 and band 2 reflectance to determine thresholds for identifying bright ice pixels (e.g., snow-covered floes or ice thicker than its surroundings). The algorithm  builds a histogram using <code>nbins</code> bins, and finds the largest peak such that the peak brightness is larger than the <code>possible_ice_threshold</code> and has prominence larger than <code>minimum_prominence</code> using a comparison window of size <code>window_size</code> (see docs for <code>Peaks.findmaxima</code>). If <code>join_method</code> = &quot;intersect&quot;, then select pixels where the band 1 brightness is larger than the band 1 peak and the band 2 brightness is larger than the band 2 peak. Otherwise, if  <code>join_method</code> = &quot;union&quot;, select pixels where either band 1 or band 2 is brighter than the threshold criteria. Finally, since clouds tend to have higher reflectance in band 7, mask pixels with the band 7 brightness larger than <code>band_7_max</code>. It is designed to be used with MODIS false color 7-2-1 imagery.</p><p>See also: <a href="@ref"><code>binarize</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; algo = IceDetectionBrightnessPeaksMODIS721(;
           band_7_max=5/255,
           possible_ice_threshold=75/255,
           join_method=&quot;union&quot;,
       )
IceDetectionBrightnessPeaksMODIS721(0.0196078431372549, 0.29411764705882354, 64, 0.01, 3, &quot;union&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L95-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IceDetectionFirstNonZeroAlgorithm(;
    algorithms::Vector{IceDetectionAlgorithm},
)(image)
binarize(image, algorithms::IceDetectionFirstNonZeroAlgorithm)</code></pre><p>Runs each algorithm from <code>algorithms</code> on the image, and returns the first which detects any ice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L174-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IceDetectionThresholdMODIS721(;
    band_7_threshold::Real,
    band_2_threshold::Real,
    band_1_threshold::Real,
)(image)
binarize(
    modis_721_image, 
    a::IceDetectionThresholdMODIS721
)</code></pre><p>Returns pixels for a MODIS image where (band<em>7 &lt; threshold AND band</em>2 &gt; threshold AND band_1 &gt; threshold).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L66-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.PixelConvexArea"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.PixelConvexArea"><code>IceFloeTracker.Segmentation.PixelConvexArea</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>PixelConvexArea(minimum_area)    PixelConvexArea(A)</p><p>Estimate the convex area by summing the number of pixels with indices falling within the polygon formed by the convex hull. Uses the convexhull function from ImageMorphology, which raises an error if the area of the segment is less than or equal to 3. In general, the error should be smaller for larger shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L319-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.PolygonConvexArea"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.PolygonConvexArea"><code>IceFloeTracker.Segmentation.PolygonConvexArea</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>PolygonConvexArea(minimum_area=4)</p><p>Estimate the convex area by integrating the area of the convex hull polygon. Uses the convexhull function from ImageMorphology, which raises an error if the area of the segment is less than or equal to 3. In general, the error should be smaller for larger shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L280-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.SegmentationComparison"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.SegmentationComparison"><code>IceFloeTracker.Segmentation.SegmentationComparison</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Results of a segmentation comparison</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L5-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.SegmentationSummary"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.SegmentationSummary"><code>IceFloeTracker.Segmentation.SegmentationSummary</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Results of a segmentation comparison</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L49-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}"><code>IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IceDetectionLopezAcosta2019(;
    band_7_threshold::Float64=Float64(5 / 255),
    band_2_threshold::Float64=Float64(230 / 255),
    band_1_threshold::Float64=Float64(240 / 255),
    band_7_threshold_relaxed::Float64=Float64(10 / 255),
    band_1_threshold_relaxed::Float64=Float64(190 / 255),
    possible_ice_threshold::Float64=Float64(75 / 255),
)</code></pre><p>Returns the first non-zero result of two threshold-based and one brightness-peak based ice detections.</p><p>Default thresholds are defined in the published Ice Floe Tracker article: Remote Sensing of the Environment 234 (2019) 111406.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L202-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}"><code>IceFloeTracker.Segmentation.addlatlon!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">addlatlon(pairedfloesdf::DataFrame, refimage::AbstractString)</code></pre><p>Add columns <code>latitude</code>, <code>longitude</code>, and pixel coordinates <code>x</code>, <code>y</code> to <code>pairedfloesdf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pairedfloesdf</code>: dataframe containing floe tracking data.</li><li><code>refimage</code>: path to reference image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L52-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}"><code>IceFloeTracker.Segmentation.binarize_segments</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">binarize_segments(segments::SegmentedImage)</code></pre><p>Find pixels in a segmented image with non-zero labels and return as a grayscale image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.component_convex_areas-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.component_convex_areas-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_convex_areas</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>component<em>convex</em>area(A; algorithm=PixelConvexArea()&quot;)</p><p>Compute the convex area of labeled regions. Two methods available: &quot;PixelConvexArea&quot; and &quot;PolygonConvexArea&quot;. The polygon method uses Green&#39;s theorem to find the area of a polygon through its line integral,  while the pixel method uses a point-in-pixel calculation to determine if pixels are inside the convex hull. In general the polygon area will be smaller than the pixel area.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L259-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.component_floes-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.component_floes-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_floes</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>component<em>floes(indexmap; minimum</em>area=1)</p><p>Given a labeled array, produce a dictionary where each entry is a binary array cropped to the location of the label.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">
julia&gt; A = zeros(Int, 8, 6); A[2:6, 1:2] .= 1; A[3:7, 4:5] .= 2; A[4:6, 3:6] .= 2;
julia&gt; A
8×6 Matrix{Int64}:
 0  0  0  0  0  0
 1  1  0  0  0  0
 1  1  0  2  2  0
 1  1  2  2  2  2
 1  1  2  2  2  2
 1  1  2  2  2  2
 0  0  0  2  2  0
 0  0  0  0  0  0

julia&gt; masks = component_floes(A)
julia&gt; Dict{Any, Any} with 3 entries:
  0 =&gt; Bool[1 1 … 1 1; 0 0 … 1 1; … ; 1 1 … 0 1; 1 1 … 1 1]
  2 =&gt; Bool[0 1 1 0; 1 1 1 1; … ; 1 1 1 1; 0 1 1 0]
  1 =&gt; Bool[1 1; 1 1; … ; 1 1; 1 1]
julia&gt; masks[2]
5×4 BitMatrix:
 0  1  1  0
 1  1  1  1
 1  1  1  1
 1  1  1  1
 0  1  1  0
julia&gt; masks[1]
5×2 BitMatrix:
 1  1
 1  1
 1  1
 1  1
 1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L131-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.component_perimeters-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.component_perimeters-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_perimeters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>component<em>perimeters(indexmap; minimum</em>area=1, algorithm=&quot;benkrid_crookes&quot;)</p><p>Estimate the perimeter of the labeled regions in <code>indexmap</code> using the specified algorithm. Algorithm options = &quot;benkrid_crookes&quot; (only option currently, will add crofton in future release) Defaults to using connectivity 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L184-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.convertcentroid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convertcentroid!(propdf, latlondata, colstodrop)</code></pre><p>Convert the centroid coordinates from row and column to latitude and longitude dropping unwanted columns specified in <code>colstodrop</code> for the output data structure. Addionally, add columns <code>x</code> and <code>y</code> with the pixel coordinates of the centroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L73-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.converttounits!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">converttounits!(propdf, latlondata, colstodrop)</code></pre><p>Convert the floe properties from pixels to kilometers and square kilometers where appropiate. Also drop the columns specified in <code>colstodrop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L101-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{ColorTypes.RGB{Float64}}, BitMatrix}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{ColorTypes.RGB{Float64}}, BitMatrix}"><code>IceFloeTracker.Segmentation.find_ice_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_ice_labels(falsecolor_image, landmask; band_7_threshold, band_2_threshold, band_1_threshold, band_7_relaxed_threshold, band_1_relaxed_threshold, possible_ice_threshold)</code></pre><p>Returns pixel indices of likely ice from false color reflectance image, using the thresholds from the Ice Floe Tracker article: Remote Sensing of the Environment 234 (2019) 111406.</p><p><strong>Arguments</strong></p><ul><li><code>falsecolor_image</code>: corrected reflectance false color image - bands [7,2,1]</li><li><code>landmask</code>: bitmatrix landmask for region of interest</li><li><code>band_7_threshold</code>: threshold value used to identify ice in band 7, N0f8(RGB intensity/255)</li><li><code>band_2_threshold</code>: threshold value used to identify ice in band 2, N0f8(RGB intensity/255)</li><li><code>band_1_threshold</code>: threshold value used to identify ice in band 2, N0f8(RGB intensity/255)</li><li><code>band_7_relaxed_threshold</code>: threshold value used to identify ice in band 7 if not found on first pass, N0f8(RGB intensity/255)</li><li><code>band_1_relaxed_threshold</code>: threshold value used to identify ice in band 1 if not found on first pass, N0f8(RGB intensity/255)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L240-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}"><code>IceFloeTracker.Segmentation.get_ice_masks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ice_masks(
    falsecolor_image,
    morph_residue,
    landmask,
    tiles,
    binarize;
    band_7_threshold,
    band_2_threshold,
    band_1_threshold,
    band_7_threshold_relaxed,
    band_1_threshold_relaxed,
    possible_ice_threshold,
    k
)</code></pre><p>Identifies potential sea ice floes using two methods: selection of a relevant k-means cluster and application of adaptive threshold binarization. For the k-means section, a series of thresholds on band 7, 2, and 1 reflectance  are applied in order to find the cluster containing bright sea ice pixels.</p><p><strong>Arguments</strong></p><ul><li><code>falsecolor_image</code>: MODIS False Color Bands 7-2-1.</li><li><code>morph_residue</code>: Grayscale sharpened and equalized image from preprocessing workflow.</li><li><code>landmask</code>: Binary landmask. </li><li><code>tiles</code>: Iterable with tile divisions.</li><li><code>binarize::Bool=true</code>: Whether to binarize the tiling.</li><li><code>band_7_threshold=5/255</code>: The threshold for band 7.</li><li><code>band_2_threshold=230/255</code>: The threshold for band 2.</li><li><code>band_1_threshold=240/255</code>: The threshold for band 1.</li><li><code>band_7_threshold_relaxed=10</code>: The relaxed threshold for band 7.</li><li><code>band_1_threshold_relaxed=190</code>: The relaxed threshold for band 1.</li><li><code>possible_ice_threshold=75/255</code>: The threshold for possible ice.</li><li><code>k=4</code>: The number of clusters to use for k-means segmentation.</li></ul><p><strong>Returns</strong></p><ul><li>Binary image with likely sea ice floes = 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/ice-masks.jl#L43-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.get_ice_peaks-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.get_ice_peaks-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.get_ice_peaks</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given the edges and counts from build_histogram, identify local maxima and return the location of the largest local maximum that is bright enough that it is possibly sea ice. Locations are determined by  the edges, which by default are the left bin edges. Note also that peaks defaults to the left side of plateaus (see Peaks.jl documentation). Returns Inf if there are no non-zero parts of the histogram with bins larger than the possible ice threshold, or if there are no detected peaks larger than the minimum prominence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L20-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.kmeans_binarization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kmeans_binarization(gray_image, false_color_image, tiles; kwargs...)</code></pre><p>Produce a binarized image tilewise by identifying pixels of bright ice, performing k-means clustering, and then selecting the k-means cluster containing the largest fraction of bright ice pixels in each tile. If less than a threshold number of bright ice pixels are detected, then a blank matrix is returned.</p><p><strong>Positional Arguments</strong></p><ul><li><code>gray_image</code>: Grayscale image to segment using k-means. </li><li><code>falsecolor_image</code>: MODIS 721 false color image to be supplied to the cluster selection algorithm.</li><li><code>tiles</code>: Tiled iterator (e.g. from <code>IceFloeTracker.get_tiles()</code>)</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>k</code>: Number of k-means clusters. Default 4.</li><li><code>maxiter</code>: Maximum number of iterations for k-means algorithm. Default 50.</li><li><code>random_seed</code>: Seed for the random number generator. Default 45.</li><li><code>cluster_selection_algorithm</code>: Binarization function to find the k-means cluster to set to 1; all other clusters set to 0.</li><li><code>threshold</code>: Minimum number of ice pixels to trigger selection of k cluster</li><li><code>minimum_overlap</code>: Argument to <code>stitch_clusters</code>, minimum number of pixels on boundary for merge</li><li><code>grayscale_threshold</code>: Argument to <code>stitch_clusters</code>, maximum grayscale difference for merge</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/k-means-segmentation.jl#L91-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.kmeans_binarization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kmeans_binarization(gray_image, false_color_image; kwargs...)</code></pre><p>Produce a binarized image by identifying pixels of bright ice, performing k-means clustering, and then selecting the k-means cluster containing the largest fraction of bright ice pixels. If no bright ice pixels are detected, then a blank matrix is returned. </p><p><strong>Positional Arguments</strong></p><ul><li><code>gray_image</code>: Grayscale image to segment using k-means.</li><li><code>falsecolor_image</code>: MODIS 7-2-1 falsecolor image, to be sent to the specified <code>ice_labels_algorithm</code>. It is recommended that this image be landmasked.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ice_labels_algorithm</code>: Binarization function to find sea ice pixels</li><li><code>k</code>: Number of k-means clusters</li><li><code>maxiter</code>: Maximum number of iterations for k-means algorithm</li><li><code>random_seed</code>: Seed for the random number generator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/k-means-segmentation.jl#L56-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.kmeans_segmentation-Tuple{AbstractArray{&lt;:ColorTypes.AbstractGray}}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.kmeans_segmentation-Tuple{AbstractArray{&lt;:ColorTypes.AbstractGray}}"><code>IceFloeTracker.Segmentation.kmeans_segmentation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kmeans_segmentation(gray_image; k=4, maxiter=50, random_seed=45)</code></pre><p>Wrapper for Clustering.kmeans which accepts a grayscale image and returns a SegmentedImage object. Optionally, one can specify the number of clusters <code>k</code><code>, the maximum number of iterations</code>maxiter<code>, and the seed for the random number generator,</code>random_seed`. Returns a SegmentedImage object. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/k-means-segmentation.jl#L6-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.regionprops"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.regionprops"><code>IceFloeTracker.Segmentation.regionprops</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>regionprops(label<em>img, intensity</em>img; properties, extra<em>properties, minimum</em>area)</p><p>Core function returning a dictionary with an entry for each returned property.</p><p>See also <a href="#IceFloeTracker.Segmentation.regionprops_table"><code>regionprops_table</code></a></p><p><strong>Arguments</strong></p><ul><li><code>label_img</code>: Image with the labeled objects of interest. May be an integer array or a SegmentedImage.</li><li><code>intensity_img</code>: (Optional) Used for generating <code>extra_properties</code>, such as a color image to use for calculating mean color in segments.</li><li><code>properties</code>: List (<code>Vector</code> or <code>Tuple</code>) of properties to be generated for each connected component in <code>label_img</code></li><li><code>extra_properties</code>: (Optional) not yet implemented. It will be set to <code>nothing</code></li><li><code>minimum_area</code>: Smallest region to calculate measures on</li><li><code>perimeter_algorithm</code>: PerimeterEstimationAlgorithm. Currently only available is BenkridCrookes.</li><li><code>convex_area_algorithm</code>: ConvexAreaEstimationAlgorithm. Options are PolygonConvexArea or PixelConvexArea, default is pixel.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Random.seed!(123);

julia&gt; bw_img = rand([0, 1], 5, 10)
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  1
 1  0  1  1  1  0  0  0  1  1
 1  1  0  1  1  0  1  0  0  1
 0  1  0  1  0  0  0  0  1  0
 1  0  0  0  0  1  0  1  0  1

 julia&gt; label_img = Images.label_components(bw_img, trues(3,3))
 5×10 Matrix{Int64}:
  1  0  1  0  0  0  0  0  0  4
  1  0  1  1  1  0  0  0  4  4
  1  1  0  1  1  0  3  0  0  4
  0  1  0  1  0  0  0  0  4  0
  1  0  0  0  0  2  0  4  0  4

 julia&gt; measures = regionprops(label_img, bw_img);

 julia&gt; for s in unique(label_img)
           println(measures.area[s],&quot;	&quot;, measures.perimeter[s])
        end
13      11.621320343559642
1       0.0
1       0.0
7       4.621320343559642</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L455-L502">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.regionprops_table"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.regionprops_table"><code>IceFloeTracker.Segmentation.regionprops_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">regionprops_table(label_img, intensity_img; properties, connectivity, extra_properties)</code></pre><p>Compute measures of labeled regions in label_img and return as a DataFrame. Optionally, include an extra image or array associated with the labels.</p><p><strong>Arguments</strong></p><ul><li><code>label_img</code>: Image with the labeled objects of interest. May be an integer array or a SegmentedImage.</li><li><code>intensity_img</code>: (Optional) Used for generating <code>extra_properties</code>, such as a color image to use for calculating mean color in segments.</li><li><code>properties</code>: List (<code>Vector</code> or <code>Tuple</code>) of properties to be generated for each connected component in <code>label_img</code></li><li><code>extra_properties</code>: (Optional) not yet implemented. It will be set to <code>nothing</code></li><li><code>minimum_area</code>: Smallest region to calculate measures on</li><li><code>perimeter_algorithm</code>: PerimeterEstimationAlgorithm. Currently only available is BenkridCrookes.</li><li><code>convex_area_algorithm</code>: ConvexAreaEstimationAlgorithm. Options are PolygonConvexArea or PixelConvexArea, default is pixel.</li></ul><p><strong>Notes</strong></p><ul><li><code>bbox</code> data (<code>max_col</code> and <code>max_row</code>) are inclusive</li></ul><p>See also <a href="#IceFloeTracker.Segmentation.regionprops"><code>regionprops</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using IceFloeTracker, Random, Images

julia&gt; Random.seed!(123);

julia&gt; bw_img = rand([0, 1], 5, 10)
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  1
 1  0  1  1  1  0  0  0  1  1
 1  1  0  1  1  0  1  0  0  1
 0  1  0  1  0  0  0  0  1  0
 1  0  0  0  0  1  0  1  0  1

julia&gt; label_img = label_components(bw_img, trues(3,3))
5×10 Matrix{Int64}:
 1  0  1  0  0  0  0  0  0  4
 1  0  1  1  1  0  0  0  4  4
 1  1  0  1  1  0  3  0  0  4
 0  1  0  1  0  0  0  0  4  0
 1  0  0  0  0  2  0  4  0  4

julia&gt; properties = [&quot;area&quot;, &quot;perimeter&quot;]
2-element Vector{String}:
 &quot;area&quot;
 &quot;perimeter&quot;

 julia&gt; regionprops_table(label_img, bw_img, properties = properties)
 4×2 DataFrame
  Row │ area   perimeter 
      │ Int32  Float64   
 ─────┼──────────────────
    1 │    13   11.6213
    2 │     1    0.0
    3 │     1    0.0
    4 │     7    4.62132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/regionprops.jl#L365-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.Segmentation.segmentation_comparison</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">segmentation_comparison(
    validated::SegmentedImage, measured::SegmentedImage
)::@NamedTuple{recall::Real, precision::Real, F_score::Real}</code></pre><p>Compares two SegmentedImages and returns values describing how similar the segmentations are.</p><p>This treats the segment labeled <code>0</code> as background.</p><p>Measures:</p><ul><li>precision: rate at which pixels in <code>validated</code> segments belong to <code>measured</code> segments</li><li>recall: rate at which pixels in <code>measured</code> segments belong to <code>validated</code> segments</li><li>F_score: harmonic mean of precision and recall</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L14-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.stitch_clusters"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.stitch_clusters"><code>IceFloeTracker.Segmentation.stitch_clusters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">stitch_clusters(tiles, segmented_image, minimum_overlap, grayscale_threshold)</code></pre><p>Stitches clusters across tile boundaries based on neighbor with largest shared boundary. The algorithm finds all pairs of segment labels at the tile edges. Then, we count the number of  times each right-hand label is paired to a left-hand label, and for pairs with at least <code>minimum_overlap</code> pixel overlap, the right-hand label is assigned as a candidate pair to the left-hand label. If the difference in grayscale intensity is less than <code>grayscale_threshold</code>, the objects are merged. The function returns an image index map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L79-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.tiled_adaptive_binarization</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>tiled<em>adaptive</em>binarization(img, tiles; minimum<em>window</em>size=). </p><pre><code class="nohighlight hljs">Applies the (AdaptiveThreshold)[https://juliaimages.org/ImageBinarization.jl/v0.1/#Adaptive-Threshold-1] binarization algorithm
to each tile in the image. Following the recommendations from ImageBinarization, the default is to use the integer window size
nearest to 1/8th the tile size if the tile is large enough. So that the window is large enough to include moderately large floes,
the default minimum window size is 100 pixels (25 km for MODIS imagery). The minimum brightness parameter masks pixels with low
grayscale intensity to prevent dark regions from getting brightened (i.e., the center of a large patch of open water).
The &quot;threshold_percentage&quot; parameter is passed to the the AdaptiveThreshold function (percentage parameter).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/find-ice-labels.jl#L282-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.view_seg-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.view_seg-Tuple{Any}"><code>IceFloeTracker.Segmentation.view_seg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">view_seg_random(s::SegmentedImage)</code></pre><p>Produce an array with the segment mean mapped to each segment label. If the SegmentedImage was produced with color type (e.g., RGB, Gray), then the result will be an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L160-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Segmentation.view_seg_random-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Segmentation.view_seg_random-Tuple{Any}"><code>IceFloeTracker.Segmentation.view_seg_random</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">view_seg_random(s::SegmentedImage)</code></pre><p>Produce an RGB image with a random color for each unique segment in <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Segmentation/segmented-image-utilities.jl#L171-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.ChainedFilterFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.ChainedFilterFunction"><code>IceFloeTracker.Tracking.ChainedFilterFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ChainedFilterFunction(filters::Vector{AbstractFloeFilterFunction})</code></pre><p>A ChainedFilterFunction is a composite function based on a set of AbstractFloeFilterFunctions. Each is applied in sequence. Thus a filter function based on the DistanceThresholdFilter and area relative error  could be made as</p><pre><code class="language-julia hljs">filter_function = ChainedFilterFunction(
    filters=[DistanceThresholdFilter(), RelativeErrorThresholdFilter(variable=:area)]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L166-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.DistanceThresholdFilter"><a class="docstring-binding" href="#IceFloeTracker.Tracking.DistanceThresholdFilter"><code>IceFloeTracker.Tracking.DistanceThresholdFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistanceThresholdFilter(time_column, dist_column, threshold_function, threshold_column)
DistanceThresholdFilter(floe, candidates)</code></pre><p>The distance threshold filter creates columns for time and distance and applies a threshold function to these columns to determine if the net travel is physically possible. The struct is initialized with names for the time and distance columns, the threshold function (a TimeDistanceFunction) and the name of the column in which to store the results. </p><pre><code class="nohighlight hljs">julia&gt; dt_test = DistanceThresholdFilter(time_colum=:Δt, dist_column=:Δx, threshold_function=LinearTimeDistanceFunction())</code></pre><p>Now, let&#39;s assume that <code>floe</code> and <code>candidates</code> are already defined. Then</p><pre><code class="nohighlight hljs">julia&gt; dt_test(floe, candidates)</code></pre><p>will modify <code>candidates</code> in place to include only rows in which the <code>LinearTimeDistanceFunction()</code> evaluates as true.  Passing <code>Val{:raw}</code> as the third argument will forgo the subsetting step so that the output of the test can be examined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L18-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.LinearTimeDistanceFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.LinearTimeDistanceFunction"><code>IceFloeTracker.Tracking.LinearTimeDistanceFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Tests the travel distance and time to a linear estimate of maximum travel distance using the formula</p><pre><code class="nohighlight hljs">max_dx = max_vel * dt + eps</code></pre><p>Epsilon should be the uncertainty in position, such that if for example the positional uncertainty is 250 m, then the maximum distance includes a 250 m buffer. The default maximum velocity is 1.5 m/s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/distance_thresholds.jl#L65-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.LogLogQuadraticTimeDistanceFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.LogLogQuadraticTimeDistanceFunction"><code>IceFloeTracker.Tracking.LogLogQuadraticTimeDistanceFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Tests the travel distance and time in log-log space against an empirically fitted quadratic function. The function is constrained by minimum and maximum times. Times less than the minimum are subject to the maximum 1-hour travel distance, while times larger than the maximum fail automatically. See Watkins et al. 2025 for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/distance_thresholds.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.LopezAcostaTimeDistanceFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.LopezAcostaTimeDistanceFunction"><code>IceFloeTracker.Tracking.LopezAcostaTimeDistanceFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>LopezAcostaTimeDistanceFunction(Δx, Δt; dt, dx)</p><p>Stepwise time delta function based on Lopez-Acosta et al. 2019. The time thresholds and the input Δt must be time objects so that conversion to seconds is possible. Displacement distances are assumed to be in meters. The final dx value is the maximum displacement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/distance_thresholds.jl#L19-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.MinimumWeightMatchingFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.MinimumWeightMatchingFunction"><code>IceFloeTracker.Tracking.MinimumWeightMatchingFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MinimumWeightMatchingFunction(columns=[:scaled_distance, :relative_error_area, ...])
MinimumWeightedMatchingFunction(candidate_pairs)</code></pre><p>Function to identify a best matching between pairs of ice floes in the DataFrame <code>candidate_pairs</code>. The <code>columns</code> variable is instantiated by the first functor call and is used to select a list of columns in <code>candidate_pairs</code> to sum. The result of the sum is the weight assigned to each pairing. Then, a best set of unique pairs is found by carrying out two grouped minimizations: first grouping by the first floe, identified by the <code>head_uuid</code> column, and finding the floe with the smallest weight, then grouping by the second floe, identified by the <code>uuid</code> column, and again  finding the floe with the smallest weight. Finally, only pairs that exist in both the forward and backward grouped minizations are identified as likely true matches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/matching_functions.jl#L3-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.PiecewiseLinearThresholdFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.PiecewiseLinearThresholdFunction"><code>IceFloeTracker.Tracking.PiecewiseLinearThresholdFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The piecewise linear threshold function is defined using two (area, value) pairs. For areas below the minimum area, it is constant at minimum value; likewise for above the maximum area. The threshold function is linear in between these two points. A return  value <code>true</code> indicates that the value is below the threshold. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/geometric_thresholds.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.PsiSCorrelationThresholdFilter"><a class="docstring-binding" href="#IceFloeTracker.Tracking.PsiSCorrelationThresholdFilter"><code>IceFloeTracker.Tracking.PsiSCorrelationThresholdFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PsiSCorrelationThresholdFunction(area_variable, threshold_column, threshold_function)
PsiSCorrelationThresholdFunction(floe, candidates, Val(:raw))</code></pre><p>Compute the psi-s correlation between a floe and a dataframe of candidate floes. Adds the  psi-s correlation,  psi-s correlation score (1 - correlation), and the result of the threshold function to the columns of <code>candidates</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L138-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.RelativeErrorThresholdFilter"><a class="docstring-binding" href="#IceFloeTracker.Tracking.RelativeErrorThresholdFilter"><code>IceFloeTracker.Tracking.RelativeErrorThresholdFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RelativeErrorThresholdFilter(variable, area_variable, threshold_column, threshold_function)
RelativeErrorThresholdFilter(floe, candidates)
RelativeErrorThresholdFilter(floe, candidates, Var(:raw))</code></pre><p>Compute and test (absolute) relative error for <code>variable</code>. The relative error between scalar variables X and Y is defined as </p><pre><code class="nohighlight hljs">err = abs(X - Y)/mean(X, Y)</code></pre><p>This function takes a scalar <code>&lt;variable&gt;</code> (which must be a named column in  the <code>candidates</code> DataFrame) and computes the relative error. Calling the function with  the variable name, <code>area_variable</code>, <code>threshold_column name</code><code>, and a</code>threshold<em>function<code>initializes the function and saves the parameter values. Once initialized, the function  takes a floe (DataFrameRow) and a DataFrame of candidate floes as arguments, and subsets the candidates to only those which evaluate as true using the</code>threshold</em>function<code>. Including the dummy variable</code>Var(:raw)` returns the candidates dataframe with the test  results without subsetting it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L72-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.ShapeDifferenceThresholdFilter"><a class="docstring-binding" href="#IceFloeTracker.Tracking.ShapeDifferenceThresholdFilter"><code>IceFloeTracker.Tracking.ShapeDifferenceThresholdFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShapeDifferenceThresholdFilter(area_variable, scale_by, threshold_column, threshold_function)
ShapeDifferenceThresholdFilter(floe, candidates)
ShapeDifferenceThresholdFilter(floe, candidates, Val(:raw))</code></pre><p>Compute and test the scaled shape difference between input <code>floe</code> and each floe in the dataframe <code>candidates</code>. Assumes that the shape difference test operates on the shape difference scaled by a variable <code>scale_by</code> and the shape difference test depends on the area. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L107-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.StepwiseLinearThresholdFunction"><a class="docstring-binding" href="#IceFloeTracker.Tracking.StepwiseLinearThresholdFunction"><code>IceFloeTracker.Tracking.StepwiseLinearThresholdFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The stepwise linear threshold function is defined using a changepoint area and two levels.  If the area is less than the changepoint area, the function returns true if the value is below <code>low_value</code> and false otherwsie; if the area is greater than or equal to the changepoint area,  then the value is tested againg <code>high_value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/geometric_thresholds.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.FilterFunction-Tuple{}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.FilterFunction-Tuple{}"><code>IceFloeTracker.Tracking.FilterFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>FilterFunction()</p><p>The default filter function for the FloeTracker. The function is an instance of ChainedFilterFunction, applying 7 individual AbstractFloeFilterFunctions in sequence:     1. DistanceThresholdFilter     2-5. RelativeErrorThresholdFilters for area, convex<em>area, major</em>axis<em>length, and minor</em>axis_length     6. ShapeDifferenceThresholdFilter     7. PsiSCorrelationThresholdFilter Filters 2-7 use PiecewiseLinearThresholdFunctions for thresholds, while Filter 1 uses a LinearTimeDistanceFunction. The default values and settings are derived in Watkins et al. 2026.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/filter_functions.jl#L190-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.add_floemasks!-Tuple{DataFrames.DataFrame, Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.add_floemasks!-Tuple{DataFrames.DataFrame, Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.Tracking.add_floemasks!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_floemasks!(props::DataFrame, floeimg::FloeLabelsImage)
add_floemasks!.(props::Vector{DataFrame}, floeimgs::Vector{FloeLabelsImage})</code></pre><p>Add a column to <code>props</code> called <code>mask</code> containing the cropped floe masks from <code>floeimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L148-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.add_passtimes!-Tuple{DataFrames.DataFrame, Dates.DateTime}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.add_passtimes!-Tuple{DataFrames.DataFrame, Dates.DateTime}"><code>IceFloeTracker.Tracking.add_passtimes!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_passtimes!(props::DataFrame, passtimes::DateTime)
add_passtimes!.(props::Vector{DataFrame}, passtimes::Vector{DateTime})</code></pre><p>Add a column <code>passtime</code> to each DataFrame in <code>props</code> containing the time of the image in which the floes were captured.</p><p><strong>Arguments</strong></p><ul><li><code>props</code>: array of DataFrames containing floe properties.</li><li><code>passtimes</code>: array of <code>DateTime</code> objects containing the time of the image in which the floes were captured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L10-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.add_uuids!-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.add_uuids!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.add_uuids!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_uuids!(df::DataFrame)
add_uuids!.(dfs::Vector{DataFrame})</code></pre><p>Assign a unique ID to each floe in a (vector of) table(s) of floe properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L42-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.add_ψs!-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.add_ψs!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.add_ψs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_ψs!(props_df::DataFrame})
add_ψs!.(props_dfs::Vector{DataFrame})</code></pre><p>Add the ψ-s curves to each row of <code>props_df</code>.</p><p>Note: each member of <code>props</code> must have a <code>mask</code> column with a binary image representing the floe.  To add floe masks see <a href="@ref"><code>addfloemasks!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L26-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.align_centroids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Align images by padding so that the centroids of each image are on the edge of or within the same pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L36-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.buildψs-Tuple{AbstractArray}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.buildψs-Tuple{AbstractArray}"><code>IceFloeTracker.Tracking.buildψs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">buildψs(floe_mask)</code></pre><p>Alternate method of <code>buildψs</code> accepting binary floe mask as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.buildψs-Tuple{Matrix{&lt;:Number}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.buildψs-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.buildψs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">buildψs(XY::Matrix{&lt;:Number};rangeout::Bool=true,
unwrap::Bool=true)</code></pre><p>Alternate method of <code>buildψs</code> accepting input vectors <code>x</code> and <code>y</code> as a 2-column matrix <code>[x y]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L134-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.buildψs-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.buildψs-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.buildψs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">buildψs(x::Vector{&lt;:Number},
           y::Vector{&lt;:Number};
           rangeout::Bool=true,
           unwrap::Bool=true)::Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Builds the ψ-s curve defined by vectors <code>x</code> and <code>y</code>.</p><p>Returns a tuple of vectors with the phases <code>ψ</code> in the first component and the traversed arclength in the second component. </p><p>Following the convention in [1], the wrapped ψ-s curve has values in [0, 2π) by default; use <code>rangeout</code> to control this behavior.</p><p>See also <a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>bwtraceboundary</code></a>, <a href="#IceFloeTracker.Tracking.resample_boundary"><code>resample_boundary</code></a></p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector of x-coordinates</li><li><code>y</code>: corresponding vector of y-coordinates</li><li><code>rangeout</code>: <code>true</code> (default) for phase values in [0, 2π); <code>false</code> for phase values in (-π, π].</li><li><code>unwrap</code>: set to <code>true</code> to get &quot;unwrapped&quot; phases (default). </li></ul><p><strong>Reference</strong></p><p>[1] McConnell, Ross, et al. &quot;psi-s correlation and dynamic time warping: two methods for tracking ice floes in SAR images.&quot; IEEE Transactions on Geoscience and Remote sensing 29.6 (1991): 1004-1012.</p><p><strong>Example</strong></p><p>The example below builds a cardioid and obtains its ψ-s curve.</p><pre><code class="language-julia-repl hljs">julia&gt; t = range(0,2pi,201);

julia&gt; x = @. cos(t)*(1-cos(t));

julia&gt; y = @. sin(t)*(1-cos(t));

julia&gt; plot(x,y) # visualize the cardioid

julia&gt; psi, s = buildψs(x,y);

julia&gt; [s psi] # inspect psi-s data
200×2 Matrix{Float64}:
 0.00049344  0.0314159
 0.0019736   0.0733034
 0.00444011  0.11938
 0.00789238  0.166055
 0.0123296   0.212929
 0.0177505   0.259894
 0.024154    0.306907
 0.0315383   0.35395
 0.0399017   0.401012
 0.0492421   0.448087
 ⋮
 7.96772     9.02377
 7.97511     9.07083
 7.98151     9.11787
 7.98693     9.16488
 7.99137     9.21185
 7.99482     9.25872
 7.99729     9.3054
 7.99877     9.35147
 7.99926     9.39336

 julia&gt; plot(s, psi) # inspect psi-s curve -- should be a straight line from (0, 0) to (8, 3π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L47-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Tracking.bwtraceboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bwtraceboundary(image::Union{Matrix{Int64},Matrix{Float64},T};
                P0::Union{Tuple{Int,Int},CartesianIndex{2},Nothing}=nothing,
                closed::Bool=true) where T&lt;:AbstractMatrix{Bool}</code></pre><p>Trace the boundary of objects in <code>image</code> </p><p>Background pixels are represented as zero. The algorithm traces the boundary counterclockwise and an initial point <code>P0</code> can be specified. If more than one boundary is detected and an initial point is provided, the boundary that contains this point is returned as a vector of CartesianIndex types. Otherwise an array of vectors is returned with all the detected boundaries in <code>image</code>. </p><p><strong>Arguments</strong></p><ul><li><code>image</code>: image, preferably binary with one single object, whose objects&#39; boundaries are to be traced.</li><li><code>P0</code>: initial point of a target boundary.</li><li><code>closed</code>: if <code>true</code> (default) makes the inital point of a boundary equal to the last point.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(Int, 13, 16); A[2:6, 2:6] .= 1; A[4:8, 7:10] .= 1; A[10:12,13:15] .= 1; A[10:12,3:6] .= 1;

julia&gt; A
13×16 Matrix{Int64}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia&gt; boundary = IceFloeTracker.bwtraceboundary(A);

julia&gt; boundary[3]
9-element Vector{CartesianIndex}:
 CartesianIndex(10, 13)
 CartesianIndex(11, 13)
 CartesianIndex(12, 13)
 CartesianIndex(12, 14)
 CartesianIndex(12, 15)
 CartesianIndex(11, 15)
 CartesianIndex(10, 15)
 CartesianIndex(10, 14)
 CartesianIndex(10, 13)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/bwtraceboundary.jl#L6-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.compute_centroid</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the centroid of a binary image. If &#39;rounded&#39;, return the nearest integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L15-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.cropfloe-Tuple{Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.cropfloe-Tuple{Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, props, i)</code></pre><p>Crops the floe delimited by the bounding box data in <code>props</code> at index <code>i</code> from the floe image <code>floesimg</code>.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, but no <code>label</code>, then returns the largest contiguous component.</p><p>If the dataframe has bounding box data <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and a <code>label</code>, then returns the component with the label. In this case, <code>floesimg</code> must be an Array{Int}.</p><p>If the dataframe has only a <code>label</code> and no bounding box data, then returns the component with the label, padded by one cell of zeroes on all sides. In this case, <code>floesimg</code> must be an Array{Int}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L57-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><a class="docstring-binding" href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col)</code></pre><p>Crops the floe delimited by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, from the floe image <code>floesimg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L102-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cropfloe(floesimg, min_row, min_col, max_row, max_col, label)</code></pre><p>Crops the floe from <code>floesimg</code> with the label <code>label</code>, returning the region bounded by <code>min_row</code>, <code>min_col</code>, <code>max_row</code>, <code>max_col</code>, and converting to a BitMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/extend_regionprops.jl#L126-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real"><a class="docstring-binding" href="#IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real"><code>IceFloeTracker.Tracking.crosscorr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">r, lags = crosscorr(u::Vector{T},
                    v::Vector{T};
                    normalize::Bool=false,
                    padmode::Symbol=:longest)</code></pre><p>Wrapper of DSP.xcorr with normalization (see https://docs.juliadsp.org/stable/convolutions/#DSP.xcorr)</p><p>Returns the pair <code>(r, lags)</code> with the cross correlation scores <code>r</code> and corresponding <code>lags</code> according to <code>padmode</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u,v</code>: real vectors which could have unequal length.</li><li><code>normalize</code>: return normalized correlation scores (<code>false</code> by default).</li><li><code>padmode</code>: either <code>:longest</code> (default) or <code>:none</code> to control padding of shorter vector with zeros.</li></ul><p><strong>Examples</strong></p><p>The example below builds two vectors, one a shifted version of the other, and computes various cross correlation scores.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 1:5;

julia&gt; x = 0.48.^n;

julia&gt; y = circshift(x,3);

julia&gt; r, lags = crosscorr(x,y,normalize=true);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.369648    -4.0
0.947531    -3.0
0.495695    -2.0
0.3231      -1.0
0.332519     0.0
0.15019      1.0
0.052469     2.0
0.0241435    3.0
0.00941878   4.0

julia&gt; r, lags = crosscorr(x,y,normalize=true,padmode=:none);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.369648    1.0
0.947531    2.0
0.495695    3.0
0.3231      4.0
0.332519    5.0
0.15019     6.0
0.052469    7.0
0.0241435   8.0
0.00941878  9.0</code></pre><p>This final example builds two vectors of different length and computes some cross correlation scores.</p><pre><code class="language-julia-repl hljs">julia&gt; n = 1:5; m = 1:3;

julia&gt; x = 0.48.^n; y = 0.48.^m;

julia&gt; r, lags = crosscorr(x,y,normalize=true);

julia&gt; [r lags]
9×2 Matrix{Float64}:
0.0          -4.0
4.14728e-17  -3.0
0.178468     -2.0
0.457473     -1.0
0.994189      0.0
0.477211      1.0
0.229061      2.0
0.105402      3.0
0.0411191     4.0

julia&gt; r, lags = crosscorr(x,y,normalize=true,padmode=:none);

julia&gt; [r lags]
7×2 Matrix{Float64}:
0.178468   1.0
0.457473   2.0
0.994189   3.0
0.477211   4.0
0.229061   5.0
0.105402   6.0
0.0411191  7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/crosscorr.jl#L4-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.floe_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.floe_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}"><code>IceFloeTracker.Tracking.floe_tracker</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">floe_tracker(props; filter_function, matching_function, minimum_floe_size, maximum_floe_size, maximum_time_step)</code></pre><p>Track ice floes over multiple observations.</p><p>Trajectories are built as follows:</p><ul><li>Assume the floes detected in observation 1 are trajectories of length 1.</li><li>For each subsequent observation at time <code>t</code>`:<ul><li>Determine the latest observation for each trajectory – these are the &quot;current trajectory heads&quot;.</li><li>Select the subset of trajectory heads observed within the window <code>maximum_time_step, t</code></li><li>Apply the filter function in order to determine possible floe pairings </li><li>Apply the matching function to produce unique pairs of floes</li><li>Update the trajectories to include the newly paired floes</li><li>Add all unmatched floes as heads for new trajectories.</li></ul></li></ul><p><strong>Arguments</strong></p><ul><li><code>props::Vector{DataFrame}</code>: A vector of DataFrames, each containing ice floe properties for a single observation time. Each DataFrame must have the following columns:<ul><li>&quot;area&quot;</li><li>&quot;min_row&quot;</li><li>&quot;min_col&quot;</li><li>&quot;max_row&quot;</li><li>&quot;max_col&quot;</li><li>&quot;row_centroid&quot;</li><li>&quot;col_centroid&quot;</li><li>&quot;convex_area&quot;</li><li>&quot;major<em>axis</em>length&quot;</li><li>&quot;minor<em>axis</em>length&quot;</li><li>&quot;orientation&quot;</li><li>&quot;perimeter&quot;</li><li>&quot;mask&quot;: 2D boolean floe image cropped to the floe location</li><li>&quot;passtime&quot;: A timestamp for the floe</li><li>&quot;psi&quot;: the psi-s curve for the floe</li><li>&quot;uuid&quot;: a universally unique identifier for each segmented floe</li></ul></li><li><code>filter_function</code>: A function that accepts a <code>floe::DataFrameRow</code> and a <code>candidates::DataFrame</code> argument, and subsets the candidates dataframe to those rows that are possible matches for <code>floe</code>.</li><li><code>matching_function</code>: A function that takes the dataframe of candidate pairs and resolves conflicts to find at most one match for each floe.</li></ul><p><strong>Returns</strong></p><p>A DataFrame with the above columns, plus extra columns:</p><ul><li>columns added by the filter function, such as similarity measures</li><li><code>head_uuid</code>, the floe which was best matched by this floe.</li><li>Trajectories are identified by: <ul><li>a unique identifier <code>ID</code> and the </li><li>UUID of the trajectory, <code>trajectory_uuid</code>.</li></ul></li></ul><p>Note: the props dataframes are modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/floe_tracker.jl#L4-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the angle and rotation rate between two observations in DataFrameRows <code>row1</code> and <code>row2</code>. <code>image_column</code> and <code>time_column</code> specify which columns to use from the DataFrameRows. <code>registration_function</code> is used to compare the two images and should return an angle. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/rotation.jl#L92-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the angle and rotation rate between a measurement in a DataFrameRow <code>measurement</code>, and all the other rows in DataFrame <code>df</code>.</p><ul><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Returns a vector of <code>NamedTuple</code>s with one entry for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and the two input rows for each comparison <code>row1</code> and <code>row2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/rotation.jl#L66-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the angle and rotation rate between observations in DataFrame <code>df</code>.</p><ul><li><code>id_column</code> is the column with the ID of the image over several observations, e.g. the floe ID.</li><li><code>image_column</code> is the column with the image to compare, </li><li><code>time_column</code> is the column with the timepoint of each observation,</li><li><code>registration_function</code> is used to compare the two images and should return an angle.</li></ul><p>Each row is compared to each other row in <code>df</code> which are:</p><ul><li>for the same object ID,</li><li>strictly older,</li><li>not older than the previous day.</li></ul><p>Returns a DataFrame with one row for each comparison, with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>, and all the other values from <code>df</code> with the column name suffix <code>1</code> for the first observation and <code>2</code> for the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/rotation.jl#L7-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the angle and rotation rate between two images <code>image1</code> and <code>image2</code> at times <code>time1</code> and <code>time2</code>. Returns a NamedTuple with the angle <code>theta_rad</code>, time difference <code>dt_sec</code> and rotation rate <code>omega_rad_per_sec</code>. <code>registration_function</code> is used to compare the two images and should return an angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/rotation.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dx, dy = grad(A::Matrix{&lt;:Number})</code></pre><p>Make gradient vector field for the set of points with coordinates in the rows of the matrix <code>A</code> with x-coordinates down column 1 and y-coordinates down column 2. Return a tuple with <code>dx</code> and <code>dy</code> in that order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dx, dy = grad(x::Vector{&lt;:Number}, y::Vector{&lt;:Number})</code></pre><p>Make gradient vector field for the set of points with coordinates in vectors <code>x</code> and <code>y</code>. Return a tuple with <code>dx</code> and <code>dy</code> in that order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.mismatch"><a class="docstring-binding" href="#IceFloeTracker.Tracking.mismatch"><code>IceFloeTracker.Tracking.mismatch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mismatch(
    fixed::AbstractArray,
    moving::AbstractArray,
    mxrot::Real,
    step::Real,
)</code></pre><p>Estimate a rotation that minimizes the &#39;mismatch&#39; of aligning <code>moving</code> with <code>fixed</code>.</p><p>Returns a pair with the mismatch score <code>mm</code> and the associated registration angle <code>rot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fixed</code>,<code>moving</code>: images to align via a rigid transformation</li><li><code>mxrot</code>: maximum rotation angle in degrees</li><li><code>step</code>: rotation angle step size in degrees</li></ul><p>The default registration angles are evenly distributed in steps of 5º around a full rotation, ensuring that no angles are repeated (since -180º == +180º).</p><p>Angles are ordered so that smaller absolute angles which are positive will be returned in the event of a tie in the shape difference. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L189-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>IceFloeTracker.Tracking.mismatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mismatch(
    fixed::AbstractArray,
    moving::AbstractArray,
    test_angles::AbstractArray,
)</code></pre><p>Estimate a rotation that minimizes the &#39;mismatch&#39; of aligning <code>moving</code> with <code>fixed</code>.</p><p>Returns a pair with the mismatch score <code>mm</code> and the associated registration angle <code>rot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fixed</code>,<code>moving</code>: images to align via a rigid transformation</li><li><code>test_angles</code>: candidate angles to check for rotations by, in degrees.  In the case of a tie in the shape difference, the earlier angle from this array will be returned.</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L161-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.norm-Tuple{Vector{&lt;:Number}}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.norm-Tuple{Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(v)</code></pre><p>Get the euclidean norm of the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/psi-s.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.normalized_cross_correlation-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractArray"><a class="docstring-binding" href="#IceFloeTracker.Tracking.normalized_cross_correlation-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractArray"><code>IceFloeTracker.Tracking.normalized_cross_correlation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normalized_cross_corr(f1,f2)</code></pre><p>Return the normalized cross-correlation between the psi-s curves <code>p1</code> and <code>p2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/crosscorr.jl#L115-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.register-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.register-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.register</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Finds the image rotation angle in <code>test_angles</code> which minimizes the shape difference between <code>im_reference</code> and <code>im_target</code>. The default test angles are shown in <code>register_default_angles_rad</code>. Use <code>imrotate_function=imrotate_bin_&lt;clockwise|counterclockwise&gt;_&lt;radians|degrees&gt;</code> to get angles &lt;clockwise|counterclockwise&gt; in &lt;radians|degrees&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L143-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.resample_boundary"><a class="docstring-binding" href="#IceFloeTracker.Tracking.resample_boundary"><code>IceFloeTracker.Tracking.resample_boundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">resample_boundary(bd_points::Vector{&lt;:CartesianIndex}, reduc_factor::Int64=2, bd::String=&quot;natural&quot;)</code></pre><p>Get a uniform set of resampled boundary points from <code>bd_points</code> using cubic splines with specified boundary conditions</p><p>The resampled set of points is obtained using parametric interpolation of the points in <code>bd_points</code>. It is assumed that the separation between a pair of adjacent points is 1.</p><p><strong>Arguments</strong></p><ul><li><code>bd_points</code>: Sequetial set of boundary points for the object of interest</li><li><code>reduc_factor</code>: Factor by which to reduce the number of points in <code>bd_points</code> (2 by default)</li></ul><p>-<code>bd</code>: Boundary condition, either &#39;natural&#39; (default) or &#39;periodic&#39;</p><p>See also <a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>bwtraceboundary</code></a></p><p><strong>Example</strong></p><p>```jldoctest; setup = :(using IceFloeTracker) julia&gt; A = zeros(Int, 13, 16); A[2:6, 2:6] .= 1; A[4:8, 7:10] .= 1; A[10:12,13:15] .= 1; A[10:12,3:6] .= 1; julia&gt; A 13×16 Matrix{Int64}:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</p><p>julia&gt; boundary = bwtraceboundary(A);</p><p>julia&gt; boundary[3] 9-element Vector{CartesianIndex}:  CartesianIndex(10, 13)  CartesianIndex(11, 13)  CartesianIndex(12, 13)  CartesianIndex(12, 14)  CartesianIndex(12, 15)  CartesianIndex(11, 15)  CartesianIndex(10, 15)  CartesianIndex(10, 14)  CartesianIndex(10, 13)</p><p>julia&gt; resample_boundary(boundary[3]) 4×2 Matrix{Float64}:  10.0     13.0  12.0357  13.5859  10.5859  15.0357  10.0     13.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/resample-boundary.jl#L3-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}"><code>IceFloeTracker.Tracking.shape_difference_rotation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the shape difference between im<em>reference and im</em>target for each angle in test<em>angles. The reference image is held constant, while the target image is rotated. The test</em>angles are interpreted as the angle of rotation from target to reference, so to find the best match, we rotate the reverse direction. A perfect match at angle <code>A</code> would imply im<em>target is the same shape as if im</em>reference was rotated by <code>A</code>.  Use <code>imrotate_function=imrotate_bin_&lt;clockwise|counterclockwise&gt;_&lt;radians|degrees&gt;</code> to get angles &lt;clockwise|counterclockwise&gt; in &lt;radians|degrees&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Tracking/register.jl#L98-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Preprocessing.LopezAcostaCloudMask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LopezAcostaCloudMask(prelim_threshold, band_7_threshold, band_2_threshold, ratio_lower, ratio_offset, ratio_upper)</code></pre><p>AbstractCloudMaskAlgorithm implementation of the cloud mask from Lopez-Acosta et al. 2019. Cloud masks algorithms are initialized with a set of parameters, then can be supplied to <code>create_cloudmask</code> as an argument. The Lopez-Acosta et al. cloudmask creates a piecewise linear bifurcation of band 2 and band 7 brightness in a MODIS 7-2-1 false color image using a sequence of thresholds on band 2 and band 7 and on the ratio of band 7 to band 2 brightness. </p><p>Example:</p><pre><code class="nohighlight hljs">using IceFloeTracker
using IceFloeTracker: Watkins2026Dataset

dataset = Watkins2026Dataset(; ref=&quot;v0.1&quot;)
case = first(filter(c -&gt; (c.case_number == 6 &amp;&amp; c.satellite == &quot;terra&quot;), dataset))
cm_algo = LopezAcostaCloudMask()
cloud_mask = create_cloudmask(modis_falsecolor(case), cm_algo)

# show image:
Gray.(cloud_mask)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/cloudmask.jl#L54-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Preprocessing.Watkins2025CloudMask</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Watkins2025CloudMask(prelim<em>threshold, band</em>7<em>threshold, band</em>2<em>threshold,                         ratio</em>lower, ratio<em>offset, ratio</em>upper, marker<em>strel,                         opening</em>strel, max<em>fill</em>size)</p><p>Extension of the Lopez-Acosta et al. 2019 with parameters calibrated to the Ice Floe Validation Dataset. The Lopez-Acosta et al. cloudmask creates a piecewise linear bifurcation of band 2 and band 7 brightness  in a MODIS 7-2-1 false color image using a sequence of thresholds on band 2 and band 7 and on the ratio of band 7 to band 2 brightness. This extension first creates a cloud mask using the LopezAcostaCloudMask, then applies morphological operations to remove speckle and smooth boundaries. Larger <code>marker_strel</code> sizes result in larger minimum cloud fragment size. The <code>opening_strel</code> is used to smooth the boundaries of cloud regions. Finally, the <code>max_fill_size</code> is passed to the imfill algorithm for filling holes that remain in the mask.</p><p>Example:</p><pre><code class="nohighlight hljs">using IceFloeTracker
using IceFloeTracker: Watkins2026Dataset

dataset = Watkins2026Dataset(; ref=&quot;v0.1&quot;)
case = first(filter(c -&gt; (c.case_number == 6 &amp;&amp; c.satellite == &quot;terra&quot;), dataset))
cm_algo = Watkins2025CloudMask()
cloud_mask = create_cloudmask(modis_falsecolor(case), cm_algo)

# show image:
Gray.(cloud_mask)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/cloudmask.jl#L139-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.apply_cloudmask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{Bool}}"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.apply_cloudmask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{Bool}}"><code>IceFloeTracker.Preprocessing.apply_cloudmask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_cloudmask(false_color_image, cloudmask)</code></pre><p>Zero out pixels containing clouds where clouds and ice are not discernable. Arguments should be of the same size.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: RGB, RGBA, or Gray image to be masked</li><li><code>cloudmask</code>: binary cloudmask with clouds = 1, else = 0</li><li><code>modify_channel_1</code>: optional keyword argument for RGB images. If true, set the first channel to 0 in the returned image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/cloudmask.jl#L242-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_landmask(input_image, landmask_binary)</code></pre><p>Zero out pixels in all channels of the input image using the binary landmask.</p><p><strong>Arguments</strong></p><ul><li><code>input_image</code>: truecolor RGB image</li><li><code>landmask_binary</code>: binary landmask with 1=land, 0=water/ice</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/landmask.jl#L62-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_landmask(img, landmask; as_indices::Bool=false)</code></pre><p>Apply the landmask to the input image, optionally returning the indices of non-masked (ocean/ice) pixels.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: input image (e.g., ice mask or RGB image)</li><li><code>landmask</code>: binary landmask (1=ocean/ice, 0=land)</li><li><code>as_indices</code>: if true, return indices of non-masked pixels; otherwise, return masked image</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/landmask.jl#L83-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.create_cloudmask"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.create_cloudmask"><code>IceFloeTracker.Preprocessing.create_cloudmask</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_cloudmask(img, f::AbstractCloudMaskAlgorithm)</code></pre><p>Cloud masks in the IFT are BitMatrix objects such that for an image I and cloudmask C, cloudy pixels can be selected by I[C], and clear-sky pixels can be selected with I[.!C]. Construction of a cloud mask uses the syntax</p><pre><code class="language-julia hljs">f = CloudMaskAlgorithm(parameters)
C = create_cloudmask(img; CloudMaskAlgorithm)</code></pre><p>By default, <code>create_cloudmask</code> uses the algorithm found in [1]. This algorithm converts a 3-channel MODIS 7-2-1 false color image into a 1-channel binary matrix in which clouds = 1 and anything else = 0. The algorithm aims to identify patches of opaque cloud while allowing thin and transparent cloud to remain. This algorithm is instantiated using</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask()</code></pre><p>In this case, the default values are applied. It can also called using a set of customized parameters. These values must be real numbers between 0 and 1. To reproduce the default parameters, you may call</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=110/255, band_7_threshold=200/255, band_2_threshold=190/255, ratio_lower=0.0, ratio_upper=0.75).</code></pre><p>A stricter cloud mask was defined in [2], covering more cloudy pixels while minimally impacting the masking of cloud-covered ice pixels.</p><pre><code class="language-julia hljs">f = LopezAcostaCloudMask(prelim_threshold=53/255, band_7_threshold=130/255, band_2_threshold=169/255, ratio_lower=0.0, ratio_upper=0.53).</code></pre><p>These parameters together define a piecewise linear partition of pixels based on their Band 7 and Band 2 callibrated reflectance. Pixels with intensity above <code>prelim_threshold</code> are considered as potential cloudy pixels. Then, pixels with Band 7 reflectance less than <code>band_7_threshold</code>, Band 2 reflectance greater than <code>band_2_threshold</code>, and Band 7 to Band 2 ratios between <code>ratio_lower</code> and <code>ratio_upper</code> are removed from the cloud mask (i.e., set to cloud-free).</p><p><strong>Arguments</strong></p><ul><li><code>false_color_image</code>: corrected reflectance false color image - bands [7,2,1]</li><li><code>prelim_threshold</code>: threshold value used to identify clouds in band 7, N0f8(RGB intensity/255)</li><li><code>band_7_threshold</code>: threshold value used to identify cloud-ice in band 7, N0f8(RGB intensity/255)</li><li><code>band_2_threshold</code>: threshold value used to identify cloud-ice in band 2, N0f8(RGB intensity/255)</li><li><code>ratio_lower</code>: threshold value used to set lower ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_upper</code>: threshold value used to set upper ratio of cloud-ice in bands 7 and 2</li><li><code>ratio_offset</code>: offset value used to adjust the upper ratio of cloud-ice in bands 7 and 2</li></ul><ol><li>Lopez-Acosta, R., Schodlok, M. P., &amp; Wilhelmus, M. M. (2019). Ice Floe Tracker: An algorithm to automatically retrieve Lagrangian trajectories via feature matching from moderate-resolution visual imagery. Remote Sensing of Environment, 234(111406), 1–15. (https://doi.org/10.1016/j.rse.2019.111406)[https://doi.org/10.1016/j.rse.2019.111406]</li><li>Watkins, D.M., Kim, M., Paniagua, C., Divoll, T., Holland, J.G., Hatcher, S., Hutchings, J.K., and Wilhelmus, M.M. (in prep). Calibration and validation of the Ice Floe Tracker algorithm. </li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/cloudmask.jl#L193-L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.Preprocessing.create_landmask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_landmask(landmask_image, struct_elem, fill_value_lower, fill_value_upper)</code></pre><p>Convert a land mask image to a 1-channel binary matrix, and use a structuring element to extend a buffer to mask complex coastal features, and fill holes in the dilated image. In the resulting mask, land = 0 and ocean = 1. Returns a named tuple with the dilated and non-dilated landmask.</p><p><strong>Arguments</strong></p><ul><li><code>landmask_image</code>: RGB land mask image from <code>fetchdata</code></li><li><code>struct_elem</code>: structuring element for dilation (optional)</li><li><code>fill_value_lower</code>: fill holes having at least these many pixels (optional)</li><li><code>fill_value_upper</code>: fill holes having at most these many pixels (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/landmask.jl#L13-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Preprocessing.make_landmask_se"><a class="docstring-binding" href="#IceFloeTracker.Preprocessing.make_landmask_se"><code>IceFloeTracker.Preprocessing.make_landmask_se</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_landmask_se()</code></pre><p>Create a structuring element for dilating the landmask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Preprocessing/landmask.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><a class="docstring-binding" href="#IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.branch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">branch(img::AbstractArray{Bool})</code></pre><p>Find branch points in skeletonized image <code>img</code> according to Definition 3 of [1].</p><p>[1] Arcelli, Carlo, and Gabriella Sanniti di Baja. &quot;Skeletons of planar patterns.&quot; Machine Intelligence and Pattern Recognition. Vol. 19. North-Holland, 1996. 99-143.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/branch.jl#L74-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><a class="docstring-binding" href="#IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.bridge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bridge(bw)</code></pre><p>Set 0-valued pixels to 1 if they have two nonzero neighbors that are not connected. Note the following exceptions:</p><p>0 0 0           0 0 0 1 0 1  becomes  1 1 1 0 0 0           0 0 0</p><p>1 0 1           1 1 1 0 0 0  becomes  0 0 0 0 0 0           0 0 0</p><p>The same applies to all their corresponding rotations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bw = [0 0 0; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 0  0  0
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 0  0  0
 0  0  0
 1  1  1

julia&gt; bw = [1 0 0; 1 0 1; 0 0 1]
3×3 Matrix{Int64}:
 1  0  0
 1  0  1
 0  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  0
 1  1  1
 0  1  1

 julia&gt; bw = [1 0 1; 0 0 0; 1 0 1]
3×3 Matrix{Int64}:
 1  0  1
 0  0  0
 1  0  1

julia&gt; bridge(bw)
3×3 BitMatrix:
 1  1  1
 1  1  1
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bridge.jl#L23-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.bwareamaxfilt"><a class="docstring-binding" href="#IceFloeTracker.Morphology.bwareamaxfilt"><code>IceFloeTracker.Morphology.bwareamaxfilt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bwareamaxfilt(bwimg::AbstractArray{Bool}, conn)</code></pre><p>Filter the smaller (by area) connected components in <code>bwimg</code> keeping the (assumed unique) largest.</p><p>Uses 8-pixel connectivity by default (<code>conn=8</code>). Use <code>conn=4</code> for 4-pixel connectivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwareamaxfilt.jl#L65-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.bwareamaxfilt!"><a class="docstring-binding" href="#IceFloeTracker.Morphology.bwareamaxfilt!"><code>IceFloeTracker.Morphology.bwareamaxfilt!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bwareamaxfilt!(bwimg::AbstractArray)</code></pre><p>In-place version of bwareamaxfilt.</p><p>See also <a href="#IceFloeTracker.Morphology.bwareamaxfilt"><code>bwareamaxfilt</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwareamaxfilt.jl#L77-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.bwperim-Tuple{T} where T&lt;:AbstractMatrix{Bool}"><a class="docstring-binding" href="#IceFloeTracker.Morphology.bwperim-Tuple{T} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Morphology.bwperim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bwperim(bwimg)</code></pre><p>Locate the pixels at the boundary of objects in an binary image <code>bwimg</code> using 8-pixel connectivity.</p><p><strong>Arguments</strong></p><ul><li><code>bwimg</code>: Binary (black/white – 1/0) image</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(Bool, 13, 16); A[2:6, 2:6] .= 1; A[4:8, 7:10] .= 1; A[10:12,13:15] .= 1; A[10:12,3:6] .= 1;

julia&gt; A
13×16 Matrix{Bool}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  1  1  1  1  1  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0

 julia&gt; bwperim(A)
13×16 Matrix{Bool}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 0  1  0  0  0  1  0  0  0  0  0  0  0  0  0  0
 0  1  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  1  0  0  0  0  0  0  0  1  0  0  0  0  0  0
 0  1  1  1  1  1  0  0  0  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  0  0  1  0  0  0  0  0  0
 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  1  0  0  1  0  0  0  0  0  0  1  0  1  0
 0  0  1  1  1  1  0  0  0  0  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwperim.jl#L3-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.filt_except_label-Tuple{Matrix{Int64}, Int64}"><a class="docstring-binding" href="#IceFloeTracker.Morphology.filt_except_label-Tuple{Matrix{Int64}, Int64}"><code>IceFloeTracker.Morphology.filt_except_label</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filt_except_label(labeled_arr::Array{Int64, 2}, label::Int64)</code></pre><p>Make 0 all values in <code>labeled_arr</code> that are not equal to <code>label</code>.</p><p>See also <a href="@ref"><code>filt_except_label!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwareamaxfilt.jl#L20-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.get_areas-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#IceFloeTracker.Morphology.get_areas-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>IceFloeTracker.Morphology.get_areas</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_areas(labeled_arr::Array{T, 2})::Dict{T, Int} where T</code></pre><p>Get the &quot;areas&quot; (count of pixels of a given label) of the connected components in <code>labeled_arr</code>.</p><p>Return a dictionary with the frequency distribution: label =&gt; count<em>of</em>label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwareamaxfilt.jl#L49-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.get_max_label-Tuple{Dict{Int64, Int64}}"><a class="docstring-binding" href="#IceFloeTracker.Morphology.get_max_label-Tuple{Dict{Int64, Int64}}"><code>IceFloeTracker.Morphology.get_max_label</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_max_label(d::Dict{Int, Int})</code></pre><p>Get the label <code>k</code> in dictionary <code>d</code> for which d[k] is maximal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/bwareamaxfilt.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><a class="docstring-binding" href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.hbreak!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbreak!(img::AbstractArray{Bool})</code></pre><p>Inplace version of <code>hbreak</code>. See also <a href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>hbreak</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/hbreak.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.hbreak-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>IceFloeTracker.Morphology.hbreak</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hbreak(img::AbstractArray{Bool})</code></pre><p>Remove H-connected pixels in the binary image <code>img</code>. See also <a href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>hbreak!</code></a> for an inplace version of this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">
julia&gt; h1 = trues(3,3); h1[[1 3], 2] .= false; h1     
3×3 BitMatrix:    
 1  0  1
 1  1  1
 1  0  1

julia&gt; h2 = trues(3,3); h2[2, [1 3]] .= false; h2     
3×3 BitMatrix:    
 1  1  1
 0  1  0
 1  1  1

julia&gt; hbreak!(h1); h1 # modify h1 inplace
3×3 BitMatrix:
 1  0  1
 1  0  1
 1  0  1

julia&gt; hbreak(h2) 
3×3 BitMatrix:
 1  1  1
 0  0  0
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/hbreak.jl#L24-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.imextendedmin"><a class="docstring-binding" href="#IceFloeTracker.Morphology.imextendedmin"><code>IceFloeTracker.Morphology.imextendedmin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imextendedmin(img)</code></pre><p>Mimics MATLAB&#39;s imextendedmin function that computes the extended-minima transform, which is the regional minima of the H-minima transform. Regional minima are connected components of pixels with a constant intensity value. This function returns a transformed bitmatrix.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: image object</li><li><code>h</code>: suppress minima below this depth threshold</li><li><code>conn</code>: neighborhood connectivity; in 2D 1 = 4-neighborhood and 2 = 8-neighborhood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/minima-transform.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.impose_minima-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractMatrix{Bool}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#IceFloeTracker.Morphology.impose_minima-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractMatrix{Bool}}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Morphology.impose_minima</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">impose_minima(I::AbstractArray{T}, BW::AbstractArray{Bool}) where {T&lt;:Integer}</code></pre><p>Use morphological reconstruction to enforce minima on the input image <code>I</code> at the positions where the binary mask <code>BW</code> is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/reconstruction.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.imregionalmin"><a class="docstring-binding" href="#IceFloeTracker.Morphology.imregionalmin"><code>IceFloeTracker.Morphology.imregionalmin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imregionalmin(img, conn=2)</code></pre><p>Compute the regional minima of the image <code>img</code> using the connectivity <code>conn</code>.</p><p>Returns a bitmatrix of the same size as <code>img</code> with the regional minima.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: Image object</li><li><code>conn</code>: Neighborhood connectivity; in 2D, 1 = 4-neighborhood and 2 = 8-neighborhood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/minima-transform.jl#L19-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.make_hbreak_dict-Tuple{}"><a class="docstring-binding" href="#IceFloeTracker.Morphology.make_hbreak_dict-Tuple{}"><code>IceFloeTracker.Morphology.make_hbreak_dict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_hbreak_dict()</code></pre><p>Build dict with the two versions of an H-connected 3x3 neighboorhood.</p><p>h1 =   [1 0 1              1 1 1              1 0 1]    </p><p>h2 =   [1 1 1              0 1 0              1 1 1]  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/hbreak.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})"><a class="docstring-binding" href="#IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.morph_fill</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">morph_fill(bw::T)::T where {T&lt;:AbstractArray{Bool}}</code></pre><p>Fill holes in binary image <code>bw</code> by setting 0-valued pixels to 1 if they are surrounded by 1-valued pixels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bw = Bool[
        0 0 0 0 0
        0 1 1 1 0
        0 1 0 1 0
        0 1 1 1 0
        0 0 0 0 0
    ];

julia&gt; morph_fill(bw)
5×5 Matrix{Bool}:
 0  0  0  0  0
 0  1  1  1  0
 0  1  1  1  0
 0  1  1  1  0
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/morph-fill.jl#L9-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Morphology.reconstruct"><a class="docstring-binding" href="#IceFloeTracker.Morphology.reconstruct"><code>IceFloeTracker.Morphology.reconstruct</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reconstruct(img, se, type, invert)</code></pre><p>Perform closing/opening by reconstruction on <code>img</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: The input image.</li><li><code>se::AbstractArray</code>: The structuring element.</li><li><code>type::String</code>: The type of morphological operation to perform. Must be either &quot;dilation&quot; (close by reconstruction) or <code>&quot;erosion&quot;</code> (open by reconstruction).</li><li><code>invert::Bool=true</code>: Invert marker and mask before reconstruction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Morphology/reconstruction.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}"><code>IceFloeTracker.Filtering.conditional_histeq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conditional_histeq(
    image,
    clouds_red,
    tiles;
    entropy_threshold::Real=4.0,
    white_threshold::Real=25.5,
    white_fraction_threshold::Real=0.4,
)</code></pre><p>Performs conditional histogram equalization on a true color image.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: The true color image to be equalized.</li><li><code>clouds_red</code>: The land/cloud masked red channel of the false color image.</li><li><code>tiles</code>: the output from <code>get_tiles(image)</code> specifying the tiling to use on the image.</li><li><code>entropy_threshold</code>: The entropy threshold used to determine if a block should be equalized. Default is 4.0.</li><li><code>white_threshold</code>: The white threshold used to determine if a pixel should be considered white. Default is 25.5.</li><li><code>white_fraction_threshold</code>: The white fraction threshold used to determine if a block should be equalized. Default is 0.4.</li></ul><p><strong>Returns</strong></p><p>The equalized true color image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/histogram_equalization.jl#L77-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})"><a class="docstring-binding" href="#IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})"><code>IceFloeTracker.Filtering.histeq</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">histeq(img)
histeq(img; nbins=64)</code></pre><p>Histogram equalization of <code>img</code> using <code>nbins</code> bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/histogram_equalization.jl#L144-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Filtering.imadjust</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">imadjust(img; low, high)</code></pre><p>Adjust the contrast of an image using linear stretching. The image is normalized to [0, 1] and then stretched to the range [low, high].</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: The input image.</li><li><code>low</code>: The lower bound of the stretched image. Default is 0.01.</li><li><code>high</code>: The upper bound of the stretched image. Default is 0.99.</li></ul><p><strong>Returns</strong></p><p>The contrast-adjusted image in the range [0, 255].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/imadjust.jl#L6-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.imgradientmag"><a class="docstring-binding" href="#IceFloeTracker.Filtering.imgradientmag"><code>IceFloeTracker.Filtering.imgradientmag</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imgradientmag(img, kernel=Images.KernelFactors.sobel)</code></pre><p>Compute the gradient magnitude of an image using the specified operator. Wrapper for ImageFiltering <code>imgradients</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/imgradientmag.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}"><a class="docstring-binding" href="#IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}"><code>IceFloeTracker.Filtering.nonlinear_diffusion</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Perform nonlinear diffusion on an input image. By default, use the Perona-Malik method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/nonlinear_diffusion.jl#L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}"><a class="docstring-binding" href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rgb2gray(rgbchannels::Array{Float64, 3})</code></pre><p>Convert an array of RGB channel data to grayscale in the range [0, 255].</p><p>Identical to MATLAB <code>rgb2gray</code> (https://www.mathworks.com/help/matlab/ref/rgb2gray.html).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/histogram_equalization.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{ColorTypes.RGB{Float64}}}"><a class="docstring-binding" href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{ColorTypes.RGB{Float64}}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rgb2gray(img::Matrix{RGB{Float64}})</code></pre><p>Convert an RGB image to grayscale in the range [0, 255].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/histogram_equalization.jl#L135-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.unsharp_mask"><a class="docstring-binding" href="#IceFloeTracker.Filtering.unsharp_mask"><code>IceFloeTracker.Filtering.unsharp_mask</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unsharp_mask(img, radius, amount, threshold)

Enhance image sharpness by weighted differencing of the image and a Gaussian blurred image.
If ``B`` is the blurred version of image ``I``, then an unsharp mask sharpened image is obtained by
``S = I + (I - B)*A``
The amount of sharpening is determined by the factor A. An option threshold can be supplied such
that the sharpening is only applied where ``I - B`` is greater than some factor.

# Arguments
img: input image
radius: standard deviation of the Gaussian blur
amount: multiplicative factor
threshold: minimum difference for applying the sharpening

# Returns
Sharpened image</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/unsharp_mask.jl#L3-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}"><code>IceFloeTracker.Filtering.unsharp_mask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unsharp_mask(image_gray, smoothing_param, intensity, clampmax)</code></pre><p>Apply unsharp masking on (equalized) grayscale ([0, <code>clampmax</code>]) image to enhance its sharpness.</p><p><strong>Arguments</strong></p><ul><li><code>image_gray</code>: The input grayscale image, typically already equalized.</li><li><code>smoothing_param::Int</code>: The pixel radius for Gaussian blurring (typically between 1 and 10).</li><li><code>intensity</code>: The amount of sharpening to apply. Higher values result in more pronounced sharpening.</li><li><code>clampmax</code>: upper limit of intensity values in the returned image.`</li></ul><p><strong>Returns</strong></p><p>The sharpened grayscale image with values clipped between 0 and <code>clapmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Filtering/unsharp_mask.jl#L61-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Data"><a class="docstring-binding" href="#IceFloeTracker.Data"><code>IceFloeTracker.Data</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Module for loading validated ice floe data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Data/Data.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Data.Watkins2026Dataset-Tuple{}"><a class="docstring-binding" href="#IceFloeTracker.Data.Watkins2026Dataset-Tuple{}"><code>IceFloeTracker.Data.Watkins2026Dataset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Watkins2026Dataset()
Watkins2026Dataset(; [ref, url, dataset_metadata_path, cache_dir])</code></pre><p>Validated ice floe data from <a href="https://github.com/danielmwatkins/ice_floe_validation_dataset">the Watkins 2026 Ice Floe Validation Dataset</a>.</p><p>The dataset is initialized with a specific <code>git</code> tag, branch or commit ID from which to load the data.</p><pre><code class="language-julia-repl hljs">julia&gt; dataset = Watkins2026Dataset(; ref=&quot;v0.1&quot;)</code></pre><p><code>Watkins2026Dataset</code> fields: </p><ul><li><code>ref</code> (optional): <code>git</code> tag, commit-id or branch from which to load the data</li><li><code>cache_dir</code> (optional): local path where the data will be stored, which defaults to <code>/tmp/Watkins2026/</code>.</li><li><code>url</code> (optional): URL of the GitHub repository with the dataset</li><li><code>dataset_metadata_path</code> (optional): path within the repository to a CSV file describing the data</li></ul><p>The dataset can be filtered using <code>Base.filter</code> or <code>DataFrames.subset</code>. This checks each case&#39;s info, and if the function returns <code>true</code>, the case is included in the returned dataset.</p><pre><code class="language-julia-repl hljs">julia&gt; dataset = filter(c -&gt; (
                        c.visible_floes == &quot;yes&quot; &amp;&amp;
                        c.cloud_category_manual == &quot;none&quot; &amp;&amp;
                        c.artifacts == &quot;no&quot;
                    ), dataset);</code></pre><p>Equivalently:</p><pre><code class="language-julia-repl hljs">julia&gt; dataset = subset(dataset, 
                        :visible_floes =&gt; c -&gt; c .== &quot;yes&quot;,
                        :cloud_category_manual =&gt; c -&gt; c .== &quot;none&quot;,
                        :artifacts =&gt; c -&gt; c .== &quot;no&quot;,
                    );</code></pre><p>The returned <code>dataset</code> (a <code>Dataset</code>) has an <code>info</code> accessor which returns a DataFrame of the cases which passed the filter:</p><pre><code class="language-julia-repl hljs">julia&gt; info(dataset)
8×28 DataFrame
    Row │ case_number  region        start_date  center_lon  center_lat  center_x  center_y  month  sea_ice_fr ⋯
        │ Int64        String31      Date        Float64     Float64     Int64     Int64     Int64  Float64    ⋯
   ─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────
      1 │          11  baffin_bay    2011-07-02    -70.7347     72.3303   -837500  -1737500      7             ⋯
      2 │          14  baffin_bay    2022-07-06    -69.0755     72.3157   -787500  -1762500      7
      3 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
      4 │          48  beaufort_sea  2021-04-27   -140.612      70.1346  -2162500    212500      4
      5 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5             ⋯
      6 │          54  beaufort_sea  2015-05-16   -136.675      70.4441  -2137500     62500      5
      7 │         128  hudson_bay    2019-04-15    -91.9847     57.853   -2612500  -2437500      4
      8 │         166  laptev_sea    2016-09-04    136.931      79.7507    -37500   1112500      9
                                                                                        20 columns omitted</code></pre><p>The <code>dataset</code> contains <code>Case</code> objects. Each Case has info fields including:</p><ul><li><code>name</code>: name of the case</li><li><code>info</code>: metadata for the case, corresponding to a row in the <code>dataset.info</code> <code>DataFrame</code></li></ul><p>Each Case has functions to access its contents:</p><ul><li><code>modis_truecolor</code>: MODIS true color image</li><li><code>modis_falsecolor</code>: MODIS false color image</li><li><code>modis_landmask</code>: MODIS landmask image</li><li><code>modis_cloudfraction</code>: MODIS cloud fraction image</li><li><code>masie_landmask</code>: MASIE landmask image</li><li><code>masie_seaice</code>: MASIE sea ice image</li><li><code>validated_binary_floes</code>: binary image of validated floes</li><li><code>validated_labeled_floes</code>: labeled image of validated floes</li><li><code>validated_floe_properties</code>: CSV file of validated floe properties</li></ul><p>The <code>dataset</code> can be iterated over to get each <code>Case</code>: Example:</p><pre><code class="language-julia-repl hljs">julia&gt; for case in dataset
           println(name(case) * 
                   &quot;: sea ice fraction: &quot; * string(info(case).sea_ice_fraction) *
                   &quot;, true color image size: &quot; * string(size(modis_truecolor(case))))
       end
011-baffin_bay-100km-20110702-aqua-250m: sea ice fraction: 0.8, true color image size: (400, 400)
014-baffin_bay-100km-20220706-terra-250m: sea ice fraction: 1.0, true color image size: (400, 400)
048-beaufort_sea-100km-20210427-aqua-250m: sea ice fraction: 1.0, true color image size: (400, 400)
048-beaufort_sea-100km-20210427-terra-250m: sea ice fraction: 1.0, true color image size: (400, 400)
054-beaufort_sea-100km-20150516-aqua-250m: sea ice fraction: 1.0, true color image size: (400, 400)
054-beaufort_sea-100km-20150516-terra-250m: sea ice fraction: 1.0, true color image size: (400, 400)
128-hudson_bay-100km-20190415-aqua-250m: sea ice fraction: 1.0, true color image size: (400, 400)
166-laptev_sea-100km-20160904-aqua-250m: sea ice fraction: 1.0, true color image size: (400, 400)</code></pre><div class="admonition is-info" id="dataset-and-dataset.data-79ed7c726ccee0d3"><header class="admonition-header">`dataset` and `dataset.data`<a class="admonition-anchor" href="#dataset-and-dataset.data-79ed7c726ccee0d3" title="Permalink"></a></header><div class="admonition-body"><p>Iterating over the <code>dataset</code> is the same as iterating over <code>dataset.data</code>,  so you could also write <code>for case in dataset.data...</code>.)</p></div></div><p>To get the first case in the dataset, you can use <code>first(...)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; first(dataset)
Case(GitHubLoader(&quot;https://github.com/danielmwatkins/ice_floe_validation_dataset/&quot;, &quot;v0.1&quot;, &quot;/tmp/Watkins2026&quot;), DataFrameRow
 Row │        case_number  region      start_date  center_lon  center_lat  center_x  center_y  month  sea_ice_fraction  mean_sea_ice_concentration  init_case_number  satellite  visible_sea_ice  visible_la ⋯
     │ Int64  Int64        String      Dates.Date  Float64     Float64     Int64     Int64     Int64  Float64           Float64                     Int64             String     String           String     ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │    20           11  baffin_bay  2011-07-02    -70.7347     72.3303   -837500  -1737500      7               0.8                       0.388                -1  aqua       yes              no         ⋯
                                                                                                                                                                                            16 columns omitted)

julia&gt; validated_labeled_floes(first(dataset))
Segmented Image with:
labels map: 400×400 Matrix{Int64}
number of labels: 105

julia&gt; modis_truecolor(first(dataset))
400×400 Array{RGBA{N0f8},2} with eltype ColorTypes.RGBA{FixedPointNumbers.N0f8}:
 RGBA{N0f8}(0.094,0.133,0.169,1.0)  RGBA{N0f8}(0.051,0.094,0.118,1.0) ...
</code></pre><div class="admonition is-success" id="Cacheing-a64d9538ba316733"><header class="admonition-header">Cacheing<a class="admonition-anchor" href="#Cacheing-a64d9538ba316733" title="Permalink"></a></header><div class="admonition-body"><p>Data are downloaded to the <code>&lt;cache_dir&gt;/&lt;ref&gt;</code>, e.g. <code>/tmp/Watkins2026/v0.1/</code>.  If a file of the correct name already exists in that path, if loaded again the cached data will be returned.</p><p>There are no checks to ensure that the cached data are up-to-date,  so if the data change in the source for that <code>ref</code>, the loader won&#39;t load the new data. In this case, you can clear the cache by deleting the cache directory,  e.g. <code>rm -r /tmp/Watkins2026/v0.1/</code>.</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Data/watkins-2026.jl#L20-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Geospatial.latlon-Tuple{AbstractString}"><a class="docstring-binding" href="#IceFloeTracker.Geospatial.latlon-Tuple{AbstractString}"><code>IceFloeTracker.Geospatial.latlon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">latlon(imgpath::AbstractString)</code></pre><p>Reads the GeoTiff located at &lt;imgpath&gt;, extracts the coordinate reference system, and produces a lookup table with for the column and row values in the same projection as the GeoTiff and a 2D array for latitude and longitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Geospatial/latlon.jl#L14-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils"><code>IceFloeTracker.ImageUtils</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Module for general image utilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/ImageUtils.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.apply_to_channels-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.apply_to_channels-Tuple{Any, Any}"><code>IceFloeTracker.ImageUtils.apply_to_channels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_to_channels(img, f)</code></pre><p>Broadcasts a function f to each channel of input image img, then recombines to return.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/misc_image_utils.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.bump_tile-Union{Tuple{S}, Tuple{Tuple{UnitRange{S}, UnitRange{S}}, Tuple{S, S}}} where S&lt;:Int64"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.bump_tile-Union{Tuple{S}, Tuple{Tuple{UnitRange{S}, UnitRange{S}}, Tuple{S, S}}} where S&lt;:Int64"><code>IceFloeTracker.ImageUtils.bump_tile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bump_tile(tile::Tuple{UnitRange{Int64}, UnitRange{Int64}}, dims::Tuple{Int,Int})::Tuple{UnitRange{Int}, UnitRange{Int}}</code></pre><p>Adjust the tile dimensions by adding extra rows and columns.</p><p><strong>Arguments</strong></p><ul><li><code>tile::Tuple{Int,Int,Int,Int}</code>: A tuple representing the tile dimensions (a, b, c, d).</li><li><code>dims::Tuple{Int,Int}</code>: A tuple representing the extra rows and columns to add (extrarows, extracols).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{UnitRange{Int}, UnitRange{Int}}</code>: A tuple of ranges representing the new tile dimensions.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; bump_tile((1:3, 1:4), (1, 1))
(1:4, 1:5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L105-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_area_missed-Tuple{Int64, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_area_missed-Tuple{Int64, Tuple{Int64, Int64}}"><code>IceFloeTracker.ImageUtils.get_area_missed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_area_missed(side_length::Int, dims::Tuple{Int,Int})::Float64</code></pre><p>Calculate the proportion of the area that is not covered by tiles of a given side length.</p><p><strong>Arguments</strong></p><ul><li><code>side_length::Int</code>: The side length of the tile.</li><li><code>dims::Tuple{Int,Int}</code>: A tuple representing the dimensions (width, height).</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The proportion of the area that is not covered by the tiles.</li></ul><p><strong>Examples</strong></p><p>``` julia&gt; get<em>area</em>missed(5, (10, 20)) 0.0</p><p>julia&gt; get<em>area</em>missed(7, (10, 20)) 0.51</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L28-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_brighten_mask-Tuple{Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_brighten_mask-Tuple{Any, Any}"><code>IceFloeTracker.ImageUtils.get_brighten_mask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_brighten_mask(equalized_gray_reconstructed_img, gamma_green)</code></pre><p><strong>Arguments</strong></p><ul><li><code>equalized_gray_reconstructed_img</code>: The equalized gray reconstructed image (uint8 in Matlab).</li><li><code>gamma_green</code>: The gamma value for the green channel (also uint8).</li></ul><p><strong>Returns</strong></p><p>Difference equalized<em>gray</em>reconstructed<em>img - gamma</em>green clamped between 0 and 255.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/brighten.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_optimal_tile_size-Tuple{Int64, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_optimal_tile_size-Tuple{Int64, Tuple{Int64, Int64}}"><code>IceFloeTracker.ImageUtils.get_optimal_tile_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_optimal_tile_size(l0::Int, dims::Tuple{Int,Int}) -&gt; Int</code></pre><p>Calculate the optimal tile size in the range [l0-1, l0+1] for the given size <code>l0</code> and image dimensions <code>dims</code>.</p><p><strong>Description</strong></p><p>This function computes the optimal tile size for tiling an area with given dimensions. It ensures that the initial tile size <code>l0</code> is at least 2 and not larger than any of the given dimensions. The function evaluates candidate tile sizes and selects the one that minimizes the area missed by its corresponding tiling. In case of a tie, it prefers the larger tile size.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; get_optimal_tile_size(3, (10, 7))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L53-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_tile_dims-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_tile_dims-Tuple{Any}"><code>IceFloeTracker.ImageUtils.get_tile_dims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tile_dims(tile)</code></pre><p>Calculate the dimensions of a tile.</p><p><strong>Arguments</strong></p><ul><li><code>tile::Tuple{UnitRange{Int},UnitRange{Int}}</code>: A tuple representing the tile dimensions.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int,Int}</code>: A tuple representing the width and height of the tile.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; get_tile_dims((1:3, 1:4))
(4, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L131-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_tile_meta-Tuple{Any}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_tile_meta-Tuple{Any}"><code>IceFloeTracker.ImageUtils.get_tile_meta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tile_meta(tile)</code></pre><p>Extracts metadata from a given tile.</p><p><strong>Arguments</strong></p><ul><li><code>tile</code>: A collection of tuples, where each tuple represents a coordinate pair.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(a, b, c, d)</code> where:<ul><li><code>a</code>: The first element of the first tuple in <code>tile</code>.</li><li><code>b</code>: The last element of the first tuple in <code>tile</code>.</li><li><code>c</code>: The first element of the last tuple in <code>tile</code>.</li><li><code>d</code>: The last element of the last tuple in <code>tile</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L84-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_tiles-Tuple{Any, Int64}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_tiles-Tuple{Any, Int64}"><code>IceFloeTracker.ImageUtils.get_tiles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tiles(array, side_length)</code></pre><p>Generate a collection of tiles from an array.</p><p>Unlike <code>TileIterator</code>, the function adjusts the bottom and right edges of the tile matrix if they are smaller than half the tile size <code>side_length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L192-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.get_tiles-Union{Tuple{T}, Tuple{Any, Tuple{T, T}}} where T&lt;:Int64"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.get_tiles-Union{Tuple{T}, Tuple{Any, Tuple{T, T}}} where T&lt;:Int64"><code>IceFloeTracker.ImageUtils.get_tiles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_tiles(array, t::Tuple{Int,Int})</code></pre><p>Generate a collection of tiles from an array.</p><p>The function adjusts the bottom and right edges of the tile matrix if they are smaller than half the tile sizes in <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/tiling.jl#L154-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.imbrighten-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.imbrighten-Tuple{Any, Any, Any}"><code>IceFloeTracker.ImageUtils.imbrighten</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">imbrighten(img, brighten_mask, bright_factor)</code></pre><p>Brighten the image using a mask and a brightening factor.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: The input image.</li><li><code>brighten_mask</code>: A mask indicating the pixels to brighten.</li><li><code>bright_factor</code>: The factor by which to brighten the pixels.</li></ul><p><strong>Returns</strong></p><ul><li>The brightened image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/brighten.jl#L13-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.ImageUtils.masker-Tuple{AbstractArray}"><a class="docstring-binding" href="#IceFloeTracker.ImageUtils.masker-Tuple{AbstractArray}"><code>IceFloeTracker.ImageUtils.masker</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">masker(mask::AbstractArray, img::AbstractArray{&lt;:Colorant})
masker(mask::AbstractArray)</code></pre><p>Returns a version of <code>img</code> with masked pixels made transparent. If <code>img</code> has an alpha channel, it is combined with the mask.</p><p>masker(mask) returns a function which can be used to apply the mask.</p><p><strong>Examples</strong></p><p>With a BitMatrix type of mask, truthy values in the mask are transparent in the output.</p><pre><code class="language-julia-repl hljs">julia&gt; using Images

julia&gt; hide = true;

julia&gt; pass = false;

julia&gt; bit_mask = [hide hide pass; pass pass hide]
2×3 Matrix{Bool}:
 1  1  0
 0  0  1

 julia&gt; img = parse.(Colorant, [&quot;red&quot; &quot;green&quot; &quot;blue&quot;; &quot;cyan&quot; &quot;magenta&quot; &quot;yellow&quot;])
2×3 Array{RGB{N0f8},2} with eltype RGB{N0f8}:
 RGB{N0f8}(1.0,0.0,0.0)  RGB{N0f8}(0.0,0.502,0.0)  RGB{N0f8}(0.0,0.0,1.0)
 RGB{N0f8}(0.0,1.0,1.0)  RGB{N0f8}(1.0,0.0,1.0)    RGB{N0f8}(1.0,1.0,0.0)

 julia&gt; masker(bit_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,1.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Using the <code>masker</code> in a pipeline is also possible:</p><pre><code class="language-julia-repl hljs">julia&gt; img |&gt; masker(bit_mask)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,1.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Where the mask is itself an image with transparency,  areas which are opaque in the mask are transparent in the output. This corresopnds to overlaying the mask over the image, and hiding in the output those areas which were masked.</p><pre><code class="language-julia-repl hljs">julia&gt; hide = AGray(0.5, 1);

julia&gt; pass = AGray(1, 0);

julia&gt; agray_mask = [hide hide pass; pass pass hide];

julia&gt; masker(agray_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,1.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Any pixels which are partially opaque in the mask, will be partially obscured in the output:</p><pre><code class="language-julia-repl hljs">julia&gt; part = AGray(0.75, 0.5)
AGray{Float64}(0.75,0.5)

julia&gt; partial_mask = [hide part pass; pass part hide]
2×3 Array{AGray{Float64},2} with eltype AGray{Float64}:
 AGray{Float64}(0.5,1.0)  AGray{Float64}(0.75,0.5)  AGray{Float64}(1.0,0.0)
 AGray{Float64}(1.0,0.0)  AGray{Float64}(0.75,0.5)  AGray{Float64}(0.5,1.0)

julia&gt; masker(partial_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.502)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,0.502)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>If the image already has transparency,  this is combined with the mask.</p><pre><code class="language-julia-repl hljs">julia&gt; imga = RGBA.(parse.(Colorant, [&quot;red&quot; &quot;transparent&quot; &quot;blue&quot;; &quot;cyan&quot; &quot;transparent&quot; &quot;yellow&quot;]))

2×3 Array{RGBA{N0f8},2} with eltype RGBA{N0f8}:
 RGBA{N0f8}(1.0,0.0,0.0,1.0)  RGBA{N0f8}(0.0,0.0,0.0,0.0)  RGBA{N0f8}(0.0,0.0,1.0,1.0)
 RGBA{N0f8}(0.0,1.0,1.0,1.0)  RGBA{N0f8}(0.0,0.0,0.0,0.0)  RGBA{N0f8}(1.0,1.0,0.0,1.0)

julia&gt; masker(agray_mask, imga)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(0.0,0.0,0.0,0.0)  ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Where the mask is an image without transparency,  any non-zero pixels are masked:</p><pre><code class="language-julia-repl hljs">julia&gt; gray_mask = Gray.([0.5 0.1 0.0; 0.0 0.0 1.0])
2×3 Array{Gray{Float64},2} with eltype Gray{Float64}:

 Gray{Float64}(0.5)  Gray{Float64}(0.1)  Gray{Float64}(0.0)
 Gray{Float64}(0.0)  Gray{Float64}(0.0)  Gray{Float64}(1.0)

julia&gt; masker(gray_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,1.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)

julia&gt; rgb_mask = parse.(Colorant, [&quot;red&quot; &quot;red&quot; &quot;black&quot;; &quot;black&quot; &quot;purple&quot; &quot;green&quot;])
2×3 Array{RGB{N0f8},2} with eltype RGB{N0f8}:
 RGB{N0f8}(1.0,0.0,0.0)  RGB{N0f8}(1.0,0.0,0.0)      RGB{N0f8}(0.0,0.0,0.0)
 RGB{N0f8}(0.0,0.0,0.0)  RGB{N0f8}(0.502,0.0,0.502)  RGB{N0f8}(0.0,0.502,0.0)

julia&gt; masker(rgb_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,1.0)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,0.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Where the mask is an array of Real numbers, 0-pixels will be completely unmasked, 1-pixels completely masked, and values between partially masked:</p><pre><code class="language-julia-repl hljs">julia&gt; real_mask = [1.0 0.5 0.1; 0.1 0.2 1.0]

2×3 Matrix{Float64}:
 1.0  0.5  0.1
 0.1  0.2  1.0

julia&gt; masker(real_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)    ARGB{N0f8}(0.0,0.502,0.0,0.502)  ARGB{N0f8}(0.0,0.0,1.0,0.902)
 ARGB{N0f8}(0.0,1.0,1.0,0.902)  ARGB{N0f8}(1.0,0.0,1.0,0.8)      ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre><p>Where values are outside of the range [0, 1],  they are clamped to whichever of 0 and 1 is nearer:</p><pre><code class="language-julia-repl hljs">julia&gt; out_of_range_mask = [5 2 0.75; -1 -2 1]
2×3 Matrix{Float64}:
  5.0   2.0  0.75
 -1.0  -2.0  1.0

julia&gt; masker(out_of_range_mask, img)
2×3 Array{ARGB{N0f8},2} with eltype ARGB{N0f8}:
 ARGB{N0f8}(1.0,0.0,0.0,0.0)  ARGB{N0f8}(0.0,0.502,0.0,0.0)  ARGB{N0f8}(0.0,0.0,1.0,0.251)
 ARGB{N0f8}(0.0,1.0,1.0,1.0)  ARGB{N0f8}(1.0,0.0,1.0,1.0)    ARGB{N0f8}(1.0,1.0,0.0,0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/ImageUtils/mask.jl#L3-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Utils.callable_store-Tuple{}"><a class="docstring-binding" href="#IceFloeTracker.Utils.callable_store-Tuple{}"><code>IceFloeTracker.Utils.callable_store</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">callable_store()</code></pre><p>Create a store and a callback function to add key-value pairs to the store.</p><p>Returns a <code>store::Dict</code> and a <code>callback::Function</code> which stores any kwargs passed to it in the <code>store</code>.</p><p><strong>Examples</strong></p><p>Basic usage is to store values using the callback function</p><pre><code class="language-julia-repl hljs">julia&gt; store, callback = callable_store()
julia&gt; store
Dict{Any, Any}()

julia&gt; callback(;foo=&quot;bar&quot;)  # echoes the updated store
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;

julia&gt; store  # values are available from the store object
Dict{Any, Any} with 1 entry:
  :foo =&gt; &quot;bar&quot;</code></pre><p>A real-world use case is to extract data from a segmentation algorithm run:</p><pre><code class="language-julia-repl hljs">julia&gt; intermediate_results, intermediate_results_callback = callable_store()
julia&gt; data = first(Watkins2026Dataset(; ref=&quot;v0.1&quot;)());
julia&gt; segments = LopezAcosta2019Tiling.Segment()(
    modis_truecolor(data),
    modis_falsecolor(data),
    modis_landmask(data);
    intermediate_results_callback,
)
Segmented Image with:
  labels map: 400×400 Matrix{Int64}
  number of labels: 12

julia&gt; intermediate_data
Dict{Any, Any} with 16 entries:
  :binarized_tiling                       =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :icemask                                =&gt; Bool[1 1 … 1 1; 1 1 … 1 1; … ; 0 0 … 1 1; 0 0 … 1 1]
  :equalized_gray                         =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :morphed_residue                        =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :L0mask                                 =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :segmented                              =&gt; Segmented Image with:…
  :prelim_icemask2                        =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :equalized_gray_sharpened_reconstructed =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :gammagreen                             =&gt; [190.35 190.23 … 182.93 185.03; 191.68 190.6 … 185.04 192.08; … ; 163.87 173.33 … 108.02 108.18; 166.14 173.3 … 112.35 112.32]
  :segment_mask                           =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :ref_img_cloudmasked                    =&gt; RGB{N0f8}[RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.008,0.706,0.761) RGB{N0f8}(0.0,0.722,0.769); RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(0.0,0.0,0.0) … RGB{N0f8}(0.039,0.702,0.784) RGB{N0f8}(0.075,0.784,0.859); … ; RGB{…
  :prelim_icemask                         =&gt; Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]
  :equalized_gray_reconstructed           =&gt; [0 0 … 0 0; 0 0 … 0 0; … ; 255 255 … 255 255; 255 255 … 255 255]
  :final                                  =&gt; Bool[0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 1 0; 0 0 … 0 0]
  :local_maxima_mask                      =&gt; [255 255 … 255 255; 255 255 … 255 255; … ; 255 255 … 255 255; 255 255 … 255 255]
  :labeled                                =&gt; [0 0 … 0 0; 0 1 … 1 0; … ; 0 0 … 9 0; 0 0 … 0 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Utils/callable_store.jl#L1-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IceFloeTracker.Utils.@persist"><a class="docstring-binding" href="#IceFloeTracker.Utils.@persist"><code>IceFloeTracker.Utils.@persist</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@persist img fname
@persist(img,fname)
@persist img
@persist(img)
@persist img fname ts
@persist(img, fname, ts)</code></pre><p>Given a reference to an image object <code>img</code>, the macro persists (saves to a file) <code>img</code> to the current working directory using <code>fname</code> as filename. Returns <code>img</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: Symbol expression representing an image object loaded in memory.</li><li><code>fname</code>: Optional filename for the persisted image.</li><li><code>ts</code>: Optional boolean to attach timestamp to <code>fname</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WilhelmusLab/IceFloeTracker.jl/blob/fb86cc2aad14d75e5f452d89d47a3006c674a5e0/src/Utils/persist.jl#L5-L19">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#IceFloeTracker.Data"><code>IceFloeTracker.Data</code></a></li><li><a href="#IceFloeTracker.ImageUtils"><code>IceFloeTracker.ImageUtils</code></a></li><li><a href="#IceFloeTracker.Preprocessing.LopezAcostaCloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Preprocessing.LopezAcostaCloudMask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.Watkins2025CloudMask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}}"><code>IceFloeTracker.Preprocessing.Watkins2025CloudMask</code></a></li><li><a href="#IceFloeTracker.Segmentation.BenkridCrookes"><code>IceFloeTracker.Segmentation.BenkridCrookes</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionAlgorithm</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionBrightnessPeaksMODIS721</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm"><code>IceFloeTracker.Segmentation.IceDetectionFirstNonZeroAlgorithm</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721"><code>IceFloeTracker.Segmentation.IceDetectionThresholdMODIS721</code></a></li><li><a href="#IceFloeTracker.Segmentation.PixelConvexArea"><code>IceFloeTracker.Segmentation.PixelConvexArea</code></a></li><li><a href="#IceFloeTracker.Segmentation.PolygonConvexArea"><code>IceFloeTracker.Segmentation.PolygonConvexArea</code></a></li><li><a href="#IceFloeTracker.Segmentation.SegmentationComparison"><code>IceFloeTracker.Segmentation.SegmentationComparison</code></a></li><li><a href="#IceFloeTracker.Segmentation.SegmentationSummary"><code>IceFloeTracker.Segmentation.SegmentationSummary</code></a></li><li><a href="#IceFloeTracker.Tracking.ChainedFilterFunction"><code>IceFloeTracker.Tracking.ChainedFilterFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.DistanceThresholdFilter"><code>IceFloeTracker.Tracking.DistanceThresholdFilter</code></a></li><li><a href="#IceFloeTracker.Tracking.LinearTimeDistanceFunction"><code>IceFloeTracker.Tracking.LinearTimeDistanceFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.LogLogQuadraticTimeDistanceFunction"><code>IceFloeTracker.Tracking.LogLogQuadraticTimeDistanceFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.LopezAcostaTimeDistanceFunction"><code>IceFloeTracker.Tracking.LopezAcostaTimeDistanceFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.MinimumWeightMatchingFunction"><code>IceFloeTracker.Tracking.MinimumWeightMatchingFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.PiecewiseLinearThresholdFunction"><code>IceFloeTracker.Tracking.PiecewiseLinearThresholdFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.PsiSCorrelationThresholdFilter"><code>IceFloeTracker.Tracking.PsiSCorrelationThresholdFilter</code></a></li><li><a href="#IceFloeTracker.Tracking.RelativeErrorThresholdFilter"><code>IceFloeTracker.Tracking.RelativeErrorThresholdFilter</code></a></li><li><a href="#IceFloeTracker.Tracking.ShapeDifferenceThresholdFilter"><code>IceFloeTracker.Tracking.ShapeDifferenceThresholdFilter</code></a></li><li><a href="#IceFloeTracker.Tracking.StepwiseLinearThresholdFunction"><code>IceFloeTracker.Tracking.StepwiseLinearThresholdFunction</code></a></li><li><a href="#IceFloeTracker.Data.Watkins2026Dataset-Tuple{}"><code>IceFloeTracker.Data.Watkins2026Dataset</code></a></li><li><a href="#IceFloeTracker.Filtering.conditional_histeq-Tuple{Any, Any, Any}"><code>IceFloeTracker.Filtering.conditional_histeq</code></a></li><li><a href="#IceFloeTracker.Filtering.histeq-Tuple{S} where S&lt;:(AbstractArray{&lt;:Integer})"><code>IceFloeTracker.Filtering.histeq</code></a></li><li><a href="#IceFloeTracker.Filtering.imadjust-Union{Tuple{AbstractArray{&lt;:Integer}}, Tuple{T}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Filtering.imadjust</code></a></li><li><a href="#IceFloeTracker.Filtering.imgradientmag"><code>IceFloeTracker.Filtering.imgradientmag</code></a></li><li><a href="#IceFloeTracker.Filtering.nonlinear_diffusion-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.AbstractGray, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, Float64, Number, Int64}"><code>IceFloeTracker.Filtering.nonlinear_diffusion</code></a></li><li><a href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Matrix{ColorTypes.RGB{Float64}}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a></li><li><a href="#IceFloeTracker.Filtering.rgb2gray-Tuple{Array{Float64, 3}}"><code>IceFloeTracker.Filtering.rgb2gray</code></a></li><li><a href="#IceFloeTracker.Filtering.unsharp_mask-Tuple{Matrix{Int64}, Any, Any, Any}"><code>IceFloeTracker.Filtering.unsharp_mask</code></a></li><li><a href="#IceFloeTracker.Filtering.unsharp_mask"><code>IceFloeTracker.Filtering.unsharp_mask</code></a></li><li><a href="#IceFloeTracker.Geospatial.latlon-Tuple{AbstractString}"><code>IceFloeTracker.Geospatial.latlon</code></a></li><li><a href="#IceFloeTracker.ImageUtils.apply_to_channels-Tuple{Any, Any}"><code>IceFloeTracker.ImageUtils.apply_to_channels</code></a></li><li><a href="#IceFloeTracker.ImageUtils.bump_tile-Union{Tuple{S}, Tuple{Tuple{UnitRange{S}, UnitRange{S}}, Tuple{S, S}}} where S&lt;:Int64"><code>IceFloeTracker.ImageUtils.bump_tile</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_area_missed-Tuple{Int64, Tuple{Int64, Int64}}"><code>IceFloeTracker.ImageUtils.get_area_missed</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_brighten_mask-Tuple{Any, Any}"><code>IceFloeTracker.ImageUtils.get_brighten_mask</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_optimal_tile_size-Tuple{Int64, Tuple{Int64, Int64}}"><code>IceFloeTracker.ImageUtils.get_optimal_tile_size</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_tile_dims-Tuple{Any}"><code>IceFloeTracker.ImageUtils.get_tile_dims</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_tile_meta-Tuple{Any}"><code>IceFloeTracker.ImageUtils.get_tile_meta</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_tiles-Tuple{Any, Int64}"><code>IceFloeTracker.ImageUtils.get_tiles</code></a></li><li><a href="#IceFloeTracker.ImageUtils.get_tiles-Union{Tuple{T}, Tuple{Any, Tuple{T, T}}} where T&lt;:Int64"><code>IceFloeTracker.ImageUtils.get_tiles</code></a></li><li><a href="#IceFloeTracker.ImageUtils.imbrighten-Tuple{Any, Any, Any}"><code>IceFloeTracker.ImageUtils.imbrighten</code></a></li><li><a href="#IceFloeTracker.ImageUtils.masker-Tuple{AbstractArray}"><code>IceFloeTracker.ImageUtils.masker</code></a></li><li><a href="#IceFloeTracker.Morphology.branch-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.branch</code></a></li><li><a href="#IceFloeTracker.Morphology.bridge-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.bridge</code></a></li><li><a href="#IceFloeTracker.Morphology.bwareamaxfilt"><code>IceFloeTracker.Morphology.bwareamaxfilt</code></a></li><li><a href="#IceFloeTracker.Morphology.bwareamaxfilt!"><code>IceFloeTracker.Morphology.bwareamaxfilt!</code></a></li><li><a href="#IceFloeTracker.Morphology.bwperim-Tuple{T} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Morphology.bwperim</code></a></li><li><a href="#IceFloeTracker.Morphology.filt_except_label-Tuple{Matrix{Int64}, Int64}"><code>IceFloeTracker.Morphology.filt_except_label</code></a></li><li><a href="#IceFloeTracker.Morphology.get_areas-Union{Tuple{Matrix{T}}, Tuple{T}} where T"><code>IceFloeTracker.Morphology.get_areas</code></a></li><li><a href="#IceFloeTracker.Morphology.get_max_label-Tuple{Dict{Int64, Int64}}"><code>IceFloeTracker.Morphology.get_max_label</code></a></li><li><a href="#IceFloeTracker.Morphology.hbreak-Tuple{Any}"><code>IceFloeTracker.Morphology.hbreak</code></a></li><li><a href="#IceFloeTracker.Morphology.hbreak!-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.hbreak!</code></a></li><li><a href="#IceFloeTracker.Morphology.imextendedmin"><code>IceFloeTracker.Morphology.imextendedmin</code></a></li><li><a href="#IceFloeTracker.Morphology.impose_minima-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractMatrix{Bool}}} where T&lt;:AbstractFloat"><code>IceFloeTracker.Morphology.impose_minima</code></a></li><li><a href="#IceFloeTracker.Morphology.imregionalmin"><code>IceFloeTracker.Morphology.imregionalmin</code></a></li><li><a href="#IceFloeTracker.Morphology.make_hbreak_dict-Tuple{}"><code>IceFloeTracker.Morphology.make_hbreak_dict</code></a></li><li><a href="#IceFloeTracker.Morphology.morph_fill-Tuple{T} where T&lt;:(AbstractArray{Bool})"><code>IceFloeTracker.Morphology.morph_fill</code></a></li><li><a href="#IceFloeTracker.Morphology.reconstruct"><code>IceFloeTracker.Morphology.reconstruct</code></a></li><li><a href="#IceFloeTracker.Preprocessing.apply_cloudmask-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{Bool}}"><code>IceFloeTracker.Preprocessing.apply_cloudmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{Any, Any}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.apply_landmask-Tuple{AbstractMatrix, BitMatrix}"><code>IceFloeTracker.Preprocessing.apply_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.create_cloudmask"><code>IceFloeTracker.Preprocessing.create_cloudmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.create_landmask-Union{Tuple{T}, Tuple{T, AbstractMatrix{Bool}}} where T&lt;:(AbstractMatrix)"><code>IceFloeTracker.Preprocessing.create_landmask</code></a></li><li><a href="#IceFloeTracker.Preprocessing.make_landmask_se"><code>IceFloeTracker.Preprocessing.make_landmask_se</code></a></li><li><a href="#IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019-Tuple{}"><code>IceFloeTracker.Segmentation.IceDetectionLopezAcosta2019</code></a></li><li><a href="#IceFloeTracker.Segmentation.addlatlon!-Tuple{DataFrames.DataFrame, AbstractString}"><code>IceFloeTracker.Segmentation.addlatlon!</code></a></li><li><a href="#IceFloeTracker.Segmentation.binarize_segments-Tuple{ImageSegmentation.SegmentedImage}"><code>IceFloeTracker.Segmentation.binarize_segments</code></a></li><li><a href="#IceFloeTracker.Segmentation.component_convex_areas-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_convex_areas</code></a></li><li><a href="#IceFloeTracker.Segmentation.component_floes-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_floes</code></a></li><li><a href="#IceFloeTracker.Segmentation.component_perimeters-Tuple{Any}"><code>IceFloeTracker.Segmentation.component_perimeters</code></a></li><li><a href="#IceFloeTracker.Segmentation.convertcentroid!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.convertcentroid!</code></a></li><li><a href="#IceFloeTracker.Segmentation.converttounits!-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.converttounits!</code></a></li><li><a href="#IceFloeTracker.Segmentation.find_ice_labels-Tuple{Matrix{ColorTypes.RGB{Float64}}, BitMatrix}"><code>IceFloeTracker.Segmentation.find_ice_labels</code></a></li><li><a href="#IceFloeTracker.Segmentation.get_ice_masks-Tuple{AbstractArray{&lt;:Union{ColorTypes.AbstractRGB, ColorTypes.Transparent3{C} where C&lt;:ColorTypes.AbstractRGB, ColorTypes.TransparentRGB}}, AbstractArray{&lt;:ColorTypes.AbstractGray}, AbstractArray{&lt;:Bool}, AbstractMatrix{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}"><code>IceFloeTracker.Segmentation.get_ice_masks</code></a></li><li><a href="#IceFloeTracker.Segmentation.get_ice_peaks-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.get_ice_peaks</code></a></li><li><a href="#IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any, Any}"><code>IceFloeTracker.Segmentation.kmeans_binarization</code></a></li><li><a href="#IceFloeTracker.Segmentation.kmeans_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.kmeans_binarization</code></a></li><li><a href="#IceFloeTracker.Segmentation.kmeans_segmentation-Tuple{AbstractArray{&lt;:ColorTypes.AbstractGray}}"><code>IceFloeTracker.Segmentation.kmeans_segmentation</code></a></li><li><a href="#IceFloeTracker.Segmentation.regionprops"><code>IceFloeTracker.Segmentation.regionprops</code></a></li><li><a href="#IceFloeTracker.Segmentation.regionprops_table"><code>IceFloeTracker.Segmentation.regionprops_table</code></a></li><li><a href="#IceFloeTracker.Segmentation.segmentation_comparison-Tuple{Union{Nothing, ImageSegmentation.SegmentedImage}, Union{Nothing, ImageSegmentation.SegmentedImage}}"><code>IceFloeTracker.Segmentation.segmentation_comparison</code></a></li><li><a href="#IceFloeTracker.Segmentation.stitch_clusters"><code>IceFloeTracker.Segmentation.stitch_clusters</code></a></li><li><a href="#IceFloeTracker.Segmentation.tiled_adaptive_binarization-Tuple{Any, Any}"><code>IceFloeTracker.Segmentation.tiled_adaptive_binarization</code></a></li><li><a href="#IceFloeTracker.Segmentation.view_seg-Tuple{Any}"><code>IceFloeTracker.Segmentation.view_seg</code></a></li><li><a href="#IceFloeTracker.Segmentation.view_seg_random-Tuple{Any}"><code>IceFloeTracker.Segmentation.view_seg_random</code></a></li><li><a href="#IceFloeTracker.Tracking.FilterFunction-Tuple{}"><code>IceFloeTracker.Tracking.FilterFunction</code></a></li><li><a href="#IceFloeTracker.Tracking.add_floemasks!-Tuple{DataFrames.DataFrame, Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}}"><code>IceFloeTracker.Tracking.add_floemasks!</code></a></li><li><a href="#IceFloeTracker.Tracking.add_passtimes!-Tuple{DataFrames.DataFrame, Dates.DateTime}"><code>IceFloeTracker.Tracking.add_passtimes!</code></a></li><li><a href="#IceFloeTracker.Tracking.add_uuids!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.add_uuids!</code></a></li><li><a href="#IceFloeTracker.Tracking.add_ψs!-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.add_ψs!</code></a></li><li><a href="#IceFloeTracker.Tracking.align_centroids-Tuple{AbstractArray{Bool}, AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.align_centroids</code></a></li><li><a href="#IceFloeTracker.Tracking.buildψs-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.buildψs</code></a></li><li><a href="#IceFloeTracker.Tracking.buildψs-Tuple{AbstractArray}"><code>IceFloeTracker.Tracking.buildψs</code></a></li><li><a href="#IceFloeTracker.Tracking.buildψs-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.buildψs</code></a></li><li><a href="#IceFloeTracker.Tracking.bwtraceboundary-Union{Tuple{Union{Matrix{Float64}, Matrix{Int64}, Matrix{UInt8}, T}}, Tuple{T}} where T&lt;:AbstractMatrix{Bool}"><code>IceFloeTracker.Tracking.bwtraceboundary</code></a></li><li><a href="#IceFloeTracker.Tracking.compute_centroid-Tuple{AbstractArray{Bool}}"><code>IceFloeTracker.Tracking.compute_centroid</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{I}, Tuple{BitMatrix, Vararg{I, 4}}} where I&lt;:Integer"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Union{Tuple{J}, Tuple{I}, Tuple{Matrix{I}, J, J, J, J, I}} where {I&lt;:Integer, J&lt;:Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.cropfloe-Tuple{Union{ImageSegmentation.SegmentedImage, BitMatrix, Matrix{&lt;:Integer}}, DataFrames.DataFrame, Integer}"><code>IceFloeTracker.Tracking.cropfloe</code></a></li><li><a href="#IceFloeTracker.Tracking.crosscorr-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Real"><code>IceFloeTracker.Tracking.crosscorr</code></a></li><li><a href="#IceFloeTracker.Tracking.floe_tracker-Tuple{Vector{DataFrames.DataFrame}, Any, Any}"><code>IceFloeTracker.Tracking.floe_tracker</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T, T}} where T&lt;:Union{Dates.DateTime, TimeZones.ZonedDateTime}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrameRow}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.get_rotation_measurements-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}"><code>IceFloeTracker.Tracking.get_rotation_measurements</code></a></li><li><a href="#IceFloeTracker.Tracking.grad-Tuple{Matrix{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a></li><li><a href="#IceFloeTracker.Tracking.grad-Tuple{Vector{&lt;:Number}, Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.grad</code></a></li><li><a href="#IceFloeTracker.Tracking.mismatch-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>IceFloeTracker.Tracking.mismatch</code></a></li><li><a href="#IceFloeTracker.Tracking.mismatch"><code>IceFloeTracker.Tracking.mismatch</code></a></li><li><a href="#IceFloeTracker.Tracking.norm-Tuple{Vector{&lt;:Number}}"><code>IceFloeTracker.Tracking.norm</code></a></li><li><a href="#IceFloeTracker.Tracking.normalized_cross_correlation-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractArray"><code>IceFloeTracker.Tracking.normalized_cross_correlation</code></a></li><li><a href="#IceFloeTracker.Tracking.register-Tuple{Any, Any}"><code>IceFloeTracker.Tracking.register</code></a></li><li><a href="#IceFloeTracker.Tracking.resample_boundary"><code>IceFloeTracker.Tracking.resample_boundary</code></a></li><li><a href="#IceFloeTracker.Tracking.shape_difference_rotation-Tuple{Any, Any, Any}"><code>IceFloeTracker.Tracking.shape_difference_rotation</code></a></li><li><a href="#IceFloeTracker.Utils.callable_store-Tuple{}"><code>IceFloeTracker.Utils.callable_store</code></a></li><li><a href="#IceFloeTracker.Utils.@persist"><code>IceFloeTracker.Utils.@persist</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="preprocessing/">Preprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 17:23">Wednesday 11 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
